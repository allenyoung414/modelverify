/******************************************************************************/
/**                                                                          **/
/**  Generated by: sec 2.9.315-beta-110124                                   **/
/**  Date: Fri May 17 15:38:22 CST 2024                                      **/
/**                                                                          **/
/******************************************************************************/


#define va_start(ap,v)  __builtin_va_start(ap,v)
#define va_end(ap)      __builtin_va_end(ap)
#define va_arg(ap,t)    __builtin_va_arg(ap,t)

typedef void Object;
void _dummy( void * );

typedef long unsigned int size_t;
extern void* memcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern void* memmove(void * __dest, const void * __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern void* memset(void * __s, int  __c, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern int memcmp(const void * __s1, const void * __s2, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern void* memchr(const void * __s, int  __c, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern char* strcpy(char *__restrict__ __dest, const char *__restrict__ __src) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strcat(char *__restrict__ __dest, const char *__restrict__ __src) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strncat(char *__restrict__ __dest, const char *__restrict__ __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern int strcmp(const char * __s1, const char * __s2) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern int strncmp(const char * __s1, const char * __s2, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern int strcoll(const char * __s1, const char * __s2) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern size_t strxfrm(char *__restrict__ __dest, const char *__restrict__ __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 2 )));
extern char* strchr(const char * __s, int  __c) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern char* strrchr(const char * __s, int  __c) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern size_t strcspn(const char * __s, const char * __reject) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern size_t strspn(const char * __s, const char * __accept) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strpbrk(const char * __s, const char * __accept) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strstr(const char * __haystack, const char * __needle) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strtok(char *__restrict__ __s, const char *__restrict__ __delim) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 2 )));
extern char* __strtok_r(char *__restrict__ __s, const char *__restrict__ __delim, char * *__restrict__ __save_ptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 2, 3 )));
extern size_t strlen(const char * __s) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern char* strerror(int  __errnum) __attribute__(( __nothrow__, __leaf__));
typedef char bool;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct 
{
    int  __val[2];

}
 __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void* __timer_t;
typedef long int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __fsword_t;
typedef long int __ssize_t;
typedef long int __syscall_slong_t;
typedef unsigned long int __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char* __caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
typedef struct 
{
    int  __count;

    union 
    {
        unsigned int  __wch;

        char  __wchb[4];

    }
      __value;

}
 __mbstate_t;
typedef struct  _G_fpos_t
{
    __off_t  __pos;

    __mbstate_t  __state;

}
 __fpos_t;
typedef struct  _G_fpos64_t
{
    __off64_t  __pos;

    __mbstate_t  __state;

}
 __fpos64_t;
struct  _IO_FILE
;
typedef struct  _IO_FILE
 __FILE;
struct  _IO_FILE
;
typedef struct  _IO_FILE
 FILE;
struct  _IO_FILE
;
struct  _IO_marker
;
struct  _IO_codecvt
;
struct  _IO_wide_data
;
typedef void _IO_lock_t;
struct  _IO_FILE
{
    int  _flags;

    char * _IO_read_ptr;

    char * _IO_read_end;

    char * _IO_read_base;

    char * _IO_write_base;

    char * _IO_write_ptr;

    char * _IO_write_end;

    char * _IO_buf_base;

    char * _IO_buf_end;

    char * _IO_save_base;

    char * _IO_backup_base;

    char * _IO_save_end;

    struct  _IO_marker
     * _markers;

    struct  _IO_FILE
     * _chain;

    int  _fileno;

    int  _flags2;

    __off_t  _old_offset;

    unsigned short  _cur_column;

    signed char  _vtable_offset;

    char  _shortbuf[1];

    _IO_lock_t * _lock;

    __off64_t  _offset;

    struct  _IO_codecvt
     * _codecvt;

    struct  _IO_wide_data
     * _wide_data;

    struct  _IO_FILE
     * _freeres_list;

    void * _freeres_buf;

    size_t  __pad5;

    int  _mode;

    char  _unused2[15 * sizeof( int ) - 4 * sizeof( void * ) - sizeof( size_t )];

}
;
typedef __fpos_t fpos_t;
extern FILE* stdin;
extern FILE* stdout;
extern FILE* stderr;
extern int remove(const char * __filename) __attribute__(( __nothrow__, __leaf__));
extern int rename(const char * __old, const char * __new) __attribute__(( __nothrow__, __leaf__));
extern FILE* tmpfile(void);
extern char* tmpnam(char * __s) __attribute__(( __nothrow__, __leaf__));
extern int fclose(FILE * __stream);
extern int fflush(FILE * __stream);
extern FILE* fopen(const char *__restrict__ __filename, const char *__restrict__ __modes);
extern FILE* freopen(const char *__restrict__ __filename, const char *__restrict__ __modes, FILE *__restrict__ __stream);
extern void setbuf(FILE *__restrict__ __stream, char *__restrict__ __buf) __attribute__(( __nothrow__, __leaf__));
extern int setvbuf(FILE *__restrict__ __stream, char *__restrict__ __buf, int  __modes, size_t  __n) __attribute__(( __nothrow__, __leaf__));
extern int fprintf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...);
extern int printf(const char *__restrict__ __format, ...);
extern int sprintf(char *__restrict__ __s, const char *__restrict__ __format, ...) __attribute__(( __nothrow__));
extern int vfprintf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg);
extern int vprintf(const char *__restrict__ __format, __gnuc_va_list  __arg);
extern int vsprintf(char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __nothrow__));
extern int snprintf(char *__restrict__ __s, size_t  __maxlen, const char *__restrict__ __format, ...) __attribute__(( __nothrow__)) __attribute__(( __format__( __printf__, 3, 4 )));
extern int vsnprintf(char *__restrict__ __s, size_t  __maxlen, const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __nothrow__)) __attribute__(( __format__( __printf__, 3, 0 )));
extern int fscanf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...);
extern int scanf(const char *__restrict__ __format, ...);
extern int sscanf(const char *__restrict__ __s, const char *__restrict__ __format, ...) __attribute__(( __nothrow__, __leaf__));
extern int fscanf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...) __asm__(  """__isoc99_fscanf");
extern int scanf(const char *__restrict__ __format, ...) __asm__(  """__isoc99_scanf");
extern int sscanf(const char *__restrict__ __s, const char *__restrict__ __format, ...) __asm__(  """__isoc99_sscanf") __attribute__(( __nothrow__, __leaf__));
extern int vfscanf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __format__( __scanf__, 2, 0 )));
extern int vscanf(const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __format__( __scanf__, 1, 0 )));
extern int vsscanf(const char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __format__( __scanf__, 2, 0 )));
extern int vfscanf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __asm__(  """__isoc99_vfscanf") __attribute__(( __format__( __scanf__, 2, 0 )));
extern int vscanf(const char *__restrict__ __format, __gnuc_va_list  __arg) __asm__(  """__isoc99_vscanf") __attribute__(( __format__( __scanf__, 1, 0 )));
extern int vsscanf(const char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __asm__(  """__isoc99_vsscanf") __attribute__(( __nothrow__, __leaf__)) __attribute__(( __format__( __scanf__, 2, 0 )));
extern int fgetc(FILE * __stream);
extern int getc(FILE * __stream);
extern int getchar(void);
extern int fputc(int  __c, FILE * __stream);
extern int putc(int  __c, FILE * __stream);
extern int putchar(int  __c);
extern char* fgets(char *__restrict__ __s, int  __n, FILE *__restrict__ __stream);
extern char* gets(char * __s) __attribute__(( __deprecated__));
extern int fputs(const char *__restrict__ __s, FILE *__restrict__ __stream);
extern int puts(const char * __s);
extern int ungetc(int  __c, FILE * __stream);
extern size_t fread(void *__restrict__ __ptr, size_t  __size, size_t  __n, FILE *__restrict__ __stream);
extern size_t fwrite(const void *__restrict__ __ptr, size_t  __size, size_t  __n, FILE *__restrict__ __s);
extern int fseek(FILE * __stream, long int  __off, int  __whence);
extern long int ftell(FILE * __stream);
extern void rewind(FILE * __stream);
extern int fgetpos(FILE *__restrict__ __stream, fpos_t *__restrict__ __pos);
extern int fsetpos(FILE * __stream, const fpos_t * __pos);
extern void clearerr(FILE * __stream) __attribute__(( __nothrow__, __leaf__));
extern int feof(FILE * __stream) __attribute__(( __nothrow__, __leaf__));
extern int ferror(FILE * __stream) __attribute__(( __nothrow__, __leaf__));
extern void perror(const char * __s);
extern int __uflow(FILE *);
extern int __overflow(FILE *, int);
typedef int wchar_t;
typedef struct 
{
    int  quot;

    int  rem;

}
 div_t;
typedef struct 
{
    long int  quot;

    long int  rem;

}
 ldiv_t;
__extension__ typedef struct 
{
    long long int  quot;

    long long int  rem;

}
 lldiv_t;
extern size_t __ctype_get_mb_cur_max(void) __attribute__(( __nothrow__, __leaf__));
extern double atof(const char * __nptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern int atoi(const char * __nptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern long int atol(const char * __nptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
__extension__ extern long long int atoll(const char * __nptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern double strtod(const char *__restrict__ __nptr, char * *__restrict__ __endptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern float strtof(const char *__restrict__ __nptr, char * *__restrict__ __endptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern long double strtold(const char *__restrict__ __nptr, char * *__restrict__ __endptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern long int strtol(const char *__restrict__ __nptr, char * *__restrict__ __endptr, int  __base) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern unsigned long int strtoul(const char *__restrict__ __nptr, char * *__restrict__ __endptr, int  __base) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
__extension__ extern long long int strtoll(const char *__restrict__ __nptr, char * *__restrict__ __endptr, int  __base) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
__extension__ extern unsigned long long int strtoull(const char *__restrict__ __nptr, char * *__restrict__ __endptr, int  __base) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern int rand(void) __attribute__(( __nothrow__, __leaf__));
extern void srand(unsigned int  __seed) __attribute__(( __nothrow__, __leaf__));
extern void* malloc(size_t  __size) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __malloc__)) __attribute__(( __alloc_size__( 1 )));
extern void* calloc(size_t  __nmemb, size_t  __size) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __malloc__)) __attribute__(( __alloc_size__( 1, 2 )));
extern void* realloc(void * __ptr, size_t  __size) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __warn_unused_result__)) __attribute__(( __alloc_size__( 2 )));
extern void free(void * __ptr) __attribute__(( __nothrow__, __leaf__));
extern void abort(void) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __noreturn__));
extern int atexit(void  (* __func)(void)) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern void exit(int  __status) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __noreturn__));
extern void _Exit(int  __status) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __noreturn__));
extern char* getenv(const char * __name) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern int system(const char * __command);
typedef int (* __compar_fn_t)(const void *, const void *);
extern void* bsearch(const void * __key, const void * __base, size_t  __nmemb, size_t  __size, __compar_fn_t  __compar) __attribute__(( __nonnull__( 1, 2, 5 )));
extern void qsort(void * __base, size_t  __nmemb, size_t  __size, __compar_fn_t  __compar) __attribute__(( __nonnull__( 1, 4 )));
extern int abs(int  __x) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern long int labs(long int  __x) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
__extension__ extern long long int llabs(long long int  __x) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern div_t div(int  __numer, int  __denom) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern ldiv_t ldiv(long int  __numer, long int  __denom) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
__extension__ extern lldiv_t lldiv(long long int  __numer, long long int  __denom) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern int mblen(const char * __s, size_t  __n) __attribute__(( __nothrow__, __leaf__));
extern int mbtowc(wchar_t *__restrict__ __pwc, const char *__restrict__ __s, size_t  __n) __attribute__(( __nothrow__, __leaf__));
extern int wctomb(char * __s, wchar_t  __wchar) __attribute__(( __nothrow__, __leaf__));
extern size_t mbstowcs(wchar_t *__restrict__ __pwcs, const char *__restrict__ __s, size_t  __n) __attribute__(( __nothrow__, __leaf__));
extern size_t wcstombs(char *__restrict__ __s, const wchar_t *__restrict__ __pwcs, size_t  __n) __attribute__(( __nothrow__, __leaf__));
typedef __gnuc_va_list va_list;
typedef void (* AssertionExit)(const char * format, va_list  args);
AssertionExit atAssertion(AssertionExit  func);
AssertionExit atFault(AssertionExit  func);
bool isCustomAssertionExit(void);
void assertion(int  expr, const char * format, ...);
void fault(int  expr, const char * format, ...);
typedef long int ptrdiff_t;
typedef struct  Type
 Type;
 typedef struct  String
 String;

extern const Type type_String;


String* create_String(const char * cstr);
char charAt_String(String * self, int  index);
String* concat_String(String * self, String * str);
bool endsWith_String(String * self, String * suffix);
int indexOfChar_String(String * self, int  ch);
int indexOfCharFrom_String(String * self, int  ch, int  fromIndex);
int indexOfString_String(String * self, String * str);
int indexOfStringFrom_String(String * self, String * str, int  fromIndex);
int lastIndexOfChar_String(String * self, int  ch);
int lastIndexOfCharFrom_String(String * self, int  ch, int  fromIndex);
int lastIndexOfString_String(String * self, String * str);
int lastIndexOfStringFrom_String(String * self, String * str, int  fromIndex);
int length_String(String * self);
bool regionMatches_String(String * self, bool  ignoreCase, int  toffset, String * other, int  ooffset, int  len);
bool regionMatchesCase_String(String * self, int  toffset, String * other, int  ooffset, int  len);
String* replace_String(String * self, char  oldChar, char  newChar);
bool startsWith_String(String * self, String * prefix);
bool startsWithOffset_String(String * self, String * prefix, int  toffset);
String* substringFrom_String(String * self, int  beginIndex);
String* substring_String(String * self, int  beginIndex, int  endIndex);
const char* toCharArray_String(String * self);
String* toLowerCase_String(String * self);
String* toUpperCase_String(String * self);
String* trim_String(String * self);
String* format_String(const char * format, ...);
String* vformat_String(const char * format, va_list  args);
String* valueOfBool_String(bool  b);
String* valueOfChar_String(char  c);
String* valueOfShort_String(short  i);
String* valueOfUShort_String(unsigned short  i);
String* valueOfInt_String(int  i);
String* valueOfUInt_String(unsigned int  i);
String* valueOfLong_String(long  l);
String* valueOfULong_String(unsigned long  l);
String* valueOfFloat_String(float  f);
String* valueOfDouble_String(double  d);
String* valueOfPtr_String(void * p);
String* valueOfObject_String(Object * ref);
String* valueOfBytes_String(const char * p, int  l);
String* XML_encode_String(String * self);
int hash_String(String * str);
Object* r(Object * ref);
Object* r_weak(Object * ref);
Object* r_hard(Object * ref);
Object* r_hard2weak(Object * ref);
Object* r_weak2hard(Object * ref);
void r_take(Object * ref);
void r_release(Object * ref);
typedef void (* Init)(void * ref, va_list * arg_list);
typedef void (* Copy)(void * src, void * dst);
typedef int (* Compare)(void * left, void * right);
typedef String* (* ToString)(void * ref);
typedef String* (* ToXML)(void * ref);
typedef bool (* CheckInvariant)(Object * ref);
typedef bool (* EnumerationCallbackFuncType)(void * ref, void * par);
typedef void (* Enumerate)(void * ref, EnumerationCallbackFuncType  callback, void * par);
typedef void (* Destroy)(void * ref);
struct  Type
{
    const char * name;

    size_t  size;

    const Type * base;

    Init  init;

    Copy  copy;

    Compare  compare;

    ToString  to_string;

    ToXML  to_XML;

    CheckInvariant  check_invariant;

    Enumerate  enumerate;

    Destroy  destroy;

}
;
extern const Type type_Object;
const Type* type(Object * ref);
const Type* TYPE(Object * ref);
size_t size_Type(const Type * type);
bool isBasicType(const Type * type1, const Type * type2);
const Type* getMaximalType(const Type * type);
Object* create_Object(const Type *, ...);
Object* va_create_Object(const Type *, va_list * arg_list);
Object* create(const Type *, ...);
Object* va_create(const Type *, va_list * arg_list);
Object* clone_Object(Object * ref);
Object* clone(Object * ref);
void set_Object(Object * ref, ...);
void set(Object * ref, ...);
void copy_Object(Object * src, Object * dst);
void copy(Object * src, Object * dst);
int compare_Object(Object * left, Object * right);
int compare(Object * left, Object * right);
bool equals_Object(Object * self, Object * ref);
bool equals(Object * self, Object * ref);
String* toString_Object(Object * ref);
String* toString(Object * ref);
String* toTrace(Object * ref);
String* toXML_Object(Object * ref);
String* toXML(Object * ref);
String* to_XML_spec(const char * type, String * value);
String* toTrace(Object * ref);
bool checkInvariant_Object(Object * ref);
bool checkInvariant(Object * ref);
void detach_Object(Object * ref);
void destroy_Object(Object * ref);
void destroy(Object * ref);
void init_Default(Object * ref, va_list * arg_list);
void copy_Default(Object * src, Object * dst);
int compare_Default(Object * left, Object * right);
String* to_string_Default(Object * ref);
String* to_XML_Default(Object * ref);
bool check_invariant_Default(Object * ref);
void enumerate_Default(Object * ref, EnumerationCallbackFuncType  callback, void * par);
void destroy_Default(Object * ref);
void init_Subtype(Object * ref, va_list * arg_list);
void copy_Subtype(Object * src, Object * dst);
int compare_Subtype(Object * left, Object * right);
String* to_string_Subtype(Object * ref);
String* to_XML_Subtype(Object * ref);
void enumerate_Subtype(Object * ref, EnumerationCallbackFuncType  callback, void * par);
void destroy_Subtype(Object * ref);
typedef enum  SECTypeKind
{
    simpleType, structType, pointerType, arrayType, specType, subType}

 SECTypeKind;
typedef struct  SECTypeDesc
 SECTypeDesc;
struct  SECTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

}
;
typedef struct  SimpleTypeDesc
 SimpleTypeDesc;
struct  SimpleTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    const char * name;

    size_t  sizeOf;

    const char * format;

}
;
typedef struct  FieldDesc
 FieldDesc;
struct  FieldDesc
{
    const char * name;

    unsigned int  offset;

    SECTypeDesc * type_desc;

}
;
typedef struct  StructTypeDesc
 StructTypeDesc;
struct  StructTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    const char * name;

    size_t  sizeOf;

    int  numFields;

    FieldDesc * fields;

}
;
typedef struct  PointerTypeDesc
 PointerTypeDesc;
struct  PointerTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    int  level;

    SECTypeDesc * base;

}
;
typedef struct  ArrayTypeDesc
 ArrayTypeDesc;
struct  ArrayTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    size_t  sizeOfElement;

    int  numElements;

    SECTypeDesc * base;

}
;
typedef struct  SpecTypeDesc
 SpecTypeDesc;
struct  SpecTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    const Type * type;

}
;
typedef bool (* InvariantCheckerPtr)(void *);
typedef struct  SubTypeDesc
 SubTypeDesc;
struct  SubTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    const char * name;

    SECTypeDesc * base;

    InvariantCheckerPtr  invariant_checker;

}
;
SECTypeDesc* ts_base_type_desc(SECTypeDesc * type_desc);
void ts_start_copy_sectype();
void ts_copy_sectype(SECTypeDesc * desc, void * dst, void * src, bool  weak);
void ts_finish_copy_sectype();
bool ts_equals_sectype(SECTypeDesc * desc, void * left, void * right);
String* ts_to_string_sectype(SECTypeDesc * desc, void * ptr);
String* ts_to_XML_sectype(SECTypeDesc * desc, void * ptr);
String* ts_to_trace_sectype(SECTypeDesc * desc, void * ptr);
bool ts_start_to_XML();
String* create_single_XML_entry(const char * kind, const char * type, String * value);
void ts_finish_to_XML();
bool ts_check_invariant_sectype(SECTypeDesc * desc, void * ptr);
void ts_enumerate_sectype(SECTypeDesc * desc, void * ptr, EnumerationCallbackFuncType  callback, void * par);
void ts_start_destroy_sectype();
void ts_destroy_sectype(SECTypeDesc * desc, void * ptr, bool  weak);
void ts_finish_destroy_sectype();
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;
typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
typedef signed char int_fast8_t;
typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef long int intptr_t;
typedef unsigned long int uintptr_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef long ChannelID;
extern const ChannelID WrongChannel;
extern const ChannelID UniqueChannel;
ChannelID getChannelID(void);
void releaseChannelID(ChannelID  chid);
typedef uint64_t LinearTimeMark;
typedef int TimeFrameOfReferenceID;
extern const TimeFrameOfReferenceID infiniteTimeFrameOfReferenceID;
extern const TimeFrameOfReferenceID systemTimeFrameOfReferenceID;
TimeFrameOfReferenceID getTimeFrameOfReferenceID(const char * name);
bool setSystemTimeFrameOfReferenceName(const char * name);
typedef struct  TimeMark
 TimeMark;
struct  TimeMark
{
    TimeFrameOfReferenceID  frame;

    LinearTimeMark  timemark;

}
;
extern const TimeMark minTimeMark;
extern const TimeMark maxTimeMark;
TimeMark createTimeMark(LinearTimeMark  timemark);
TimeMark createDistributedTimeMark(TimeFrameOfReferenceID  frame, LinearTimeMark  timemark);
void setTimeMarkDependence(TimeMark  former, TimeMark  latter);
typedef enum  CompareResult
{
    EqualCR, LessCR, GreaterCR, NonComparableCR}

 CompareResult;
CompareResult compareTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool equalTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool lessTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool lessOrEqualTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool greaterTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool greaterOrEqualTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool noncomparableTimeMarks(TimeMark  tm1, TimeMark  tm2);
typedef int64_t TimeUnit;
TimeUnit diffTimeMarks(TimeMark  tm1, TimeMark  tm2);
TimeMark addTimeMarks(TimeMark  tm, TimeUnit  delta);
TimeMark subtractTimeMarks(TimeMark  tm, TimeUnit  delta);
typedef struct  TimeInterval
 TimeInterval;
struct  TimeInterval
{
    TimeMark  minMark;

    TimeMark  maxMark;

}
;
extern const TimeInterval overallTimeInterval;
TimeInterval createTimeInterval(TimeMark  minMark, TimeMark  maxMark);
bool areIntersectedTimeIntervals(TimeInterval  ti1, TimeInterval  ti2);
TimeInterval addTimeIntervals(TimeInterval  ti, TimeUnit  delta);
TimeInterval subtractTimeIntervals(TimeInterval  ti, TimeUnit  delta);
int printLinearTimeInterval(char * buffer, TimeInterval  interval);
int printDistributedTimeInterval(char * buffer, TimeInterval  interval);
bool setAutomaticTimeMarksMode(bool  enable);
bool areAutomaticTimeMarksEnabled(void);
TimeMark getCurrentTimeMark(void);
typedef TimeMark (* GetCurrentTimeMarkFuncType)(void);
GetCurrentTimeMarkFuncType setDefaultCurrentTimeMarkFunction(GetCurrentTimeMarkFuncType  new_func);
void setAutomaticTimeMark(TimeMark * timemark);
typedef enum  TSTimeModel
{
    NotUseTSTime, LinearTSTime, DistributedTSTime}

 TSTimeModel;
TSTimeModel setTSTimeModel(TSTimeModel  time_model);
TSTimeModel getTSTimeModel(void);
typedef struct  CallProperties
 CallProperties;
struct  CallProperties
{
    bool  verdict;

    TimeInterval  time;

}
;
typedef long InteractionId;
typedef struct  OracleCallProperties
 OracleCallProperties;
struct  OracleCallProperties
{
    InteractionId  refId;

    bool  verdict;

}
;
void setOracleVerdict(bool  verdict);
bool getOracleVerdict(void);
void clearOracleVerdict(void);
typedef enum  OracleVerdict
{
    OracleVerdict_Ok, OracleVerdict_PreconditionFailed, OracleVerdict_PostconditionFailed}

 OracleVerdict;
typedef struct  CallContextStruct
{
    Object * params;

    TimeInterval  time;

    InteractionId  refId;

}
 CallContextType;
typedef bool (* PreFuncType)(Object * params);
typedef OracleVerdict (* CallPureOracleFuncType)(CallContextType);
typedef void (* TraceModelOperationFuncType)(InteractionId, Object *, ChannelID, TimeInterval);
typedef struct  SpecificationDesc
{
    const char * name;

    const char * subsystem;

    const char * signature;

    PreFuncType  precondition;

    CallPureOracleFuncType  call_pure_oracle;

    TraceModelOperationFuncType  trace_model_operation;

    bool  is_reaction;

    const Type * par_res_type;

}
 SpecificationDesc;
typedef SpecificationDesc* SpecificationID;
typedef Object* (* PtrActionInit)(void);
typedef bool (* PtrActionHasNext)(Object *);
typedef bool (* PtrActionNext)(Object *);
typedef bool (* PtrActionCall)(Object *);
typedef struct 
{
    PtrActionInit  init;

    PtrActionHasNext  has_next;

    PtrActionNext  next;

    PtrActionCall  call;

    const char * name;

}
 ScenarioFunctionDesc;
typedef ScenarioFunctionDesc* ScenarioFunctionID;
void ts_trace_model_operation_timestamp(TimeInterval  timestamp);
void ts_trace_bad_oracle_verdict(void);
void ts_trace_bad_mediator_verdict(void);
Object* * ts_cast_spec_ref_lvalue(const Type * type, Object * * ref);
Object* ts_cast_spec_ref(const Type * type, Object * ref);
Object* ts_check_spec_ref(const Type * type, Object * ref, const char * kind, const char * where);
Object* ts_assign_spec_ref(Object * * left, Object * right, const char * where);
void* ts_destroy_spec_ref(Object * ref);
void _dummy(void * p);
Object* singletonState(void);
void setCheckPrecondition(bool  check);
bool getCheckPrecondition(void);
void setCheckPostcondition(bool  check);
bool getCheckPostcondition(void);
extern const char PRECONDITION_FAILED_MESSAGE[];
extern const char POSTCONDITION_FAILED_MESSAGE[];
extern const char SCENARIO_FUNCTION_FAILED_MESSAGE[];
extern const char INCORRECT_SET_OF_INTERACTIONS_MESSAGE[];
extern const char MEDIATOR_FAILED_MESSAGE[];
extern const char UNCONNECTED_GRAPH_MESSAGE[];
extern const char NONDETERMINISTIC_GRAPH_MESSAGE[];
extern const char SCENARIO_INITIALIZATION_FAILED_MESSAGE[];
extern const char SERIALIZATION_FAILED_MESSAGE[];
extern const char NONSTATIONARY_STATE_MESSAGE[];
void registerReaction(ChannelID  chid, const char * name, SpecificationID  reactionID, Object * data);
void registerReactionWithTimeMark(ChannelID  chid, const char * name, SpecificationID  reactionID, Object * data, TimeMark  mark);
void registerReactionWithTimeInterval(ChannelID  chid, const char * name, SpecificationID  reactionID, Object * data, TimeInterval  interval);
void registerWrongReaction(const char * info);
typedef bool (* ReactionCatcherFuncType)(void *);
void registerReactionCatcher(ReactionCatcherFuncType  catcher, void * par);
bool unregisterReactionCatcher(ReactionCatcherFuncType  catcher, void * par);
bool unregisterReactionCatchers(ReactionCatcherFuncType  catcher);
ChannelID setStimulusChannel(ChannelID  chid);
ChannelID getStimulusChannel(void);
void registerStimulus(const char * name, SpecificationID  stimulusID, Object * data, TimeInterval  interval);
void registerStimulusWithTimeInterval(ChannelID  chid, const char * name, SpecificationID  stimulusID, TimeInterval  interval, ...);
typedef __clock_t clock_t;
typedef __time_t time_t;
struct  tm
{
    int  tm_sec;

    int  tm_min;

    int  tm_hour;

    int  tm_mday;

    int  tm_mon;

    int  tm_year;

    int  tm_wday;

    int  tm_yday;

    int  tm_isdst;

    long int  __tm_gmtoff;

    const char * __tm_zone;

}
;
extern clock_t clock(void) __attribute__(( __nothrow__, __leaf__));
extern time_t time(time_t * __timer) __attribute__(( __nothrow__, __leaf__));
extern double difftime(time_t  __time1, time_t  __time0) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern time_t mktime(struct  tm
 * __tp) __attribute__(( __nothrow__, __leaf__));
extern size_t strftime(char *__restrict__ __s, size_t  __maxsize, const char *__restrict__ __format, const struct  tm
 *__restrict__ __tp) __attribute__(( __nothrow__, __leaf__));
extern struct  tm
* gmtime(const time_t * __timer) __attribute__(( __nothrow__, __leaf__));
extern struct  tm
* localtime(const time_t * __timer) __attribute__(( __nothrow__, __leaf__));
extern char* asctime(const struct  tm
 * __tp) __attribute__(( __nothrow__, __leaf__));
extern char* ctime(const time_t * __timer) __attribute__(( __nothrow__, __leaf__));
extern char* __tzname[2];
extern int __daylight;
extern long int __timezone;
typedef enum 
{
    TD_ok, TD_bad_parameters, TD_not_enough_resources, TD_bad_verdict, TD_faulted, ORACLE_bad_verdict}

 TestVerdict;
extern TestVerdict testVerdict;
typedef enum 
{
    UNTIL_ERROR, UNTIL_END}

 FinishMode;
FinishMode setFinishMode(FinishMode  finish_mode);
FinishMode getFinishMode(void);
int setNumberOfErrorsToFinish(int  error_number);
typedef enum  TSMode
{
    SequentialTSMode, ParallelTSMode}

 TSMode;
TSMode getTSMode(void);
bool setDeferredReactionsMode(bool  enable);
bool areDeferredReactionsEnabled(void);
time_t setWTime(time_t  secs);
time_t setWTimeMSec(time_t  millisecs);
time_t getWTime(void);
time_t getWTimeMSec(void);
bool setFindFirstSeriesOnly(bool  new_value);
bool isFindFirstSeriesOnly(void);
int setFindFirstSeriesOnlyBound(int  bound);
int getFindFirstSeriesOnlyBound(void);
void ts_assert_function(const char * format, va_list  arg_list);
bool startTestSystem(int  argc, char * * argv);
void stopTestSystem(void);
const char* getCurrentTestScenarioName(void);
typedef bool (* PtrIsStationaryState)(void);
typedef Object* (* PtrSaveModelState)(void);
typedef void (* PtrRestoreModelState)(Object *);
typedef void (* PtrObserveState)(void);
typedef void (* PtrDoneEvent)(void);
typedef struct  ModelStateManager
{
    PtrSaveModelState  saveModelState;

    PtrRestoreModelState  restoreModelState;

    PtrIsStationaryState  isStationaryState;

    PtrObserveState  observeState;

}
 ModelStateManager;
typedef bool (* TS_Init)(int, char * *);
typedef void (* TS_Finish)(void);
typedef Object* (* TS_GetState)(void);
typedef String* (* TS_GetStateId)(Object *);
typedef bool (* TS_IsStationaryState)(void);
typedef Object* (* TS_SaveModelState)(void);
typedef void (* TS_RestoreModelState)(Object *);
typedef void (* TS_ObserveState)(void);
typedef struct  TestScenario
{
    const char * name;

    TS_Init  init;

    TS_GetState  getState;

    TS_GetStateId  getStateId;

    TS_SaveModelState  saveModelState;

    TS_RestoreModelState  restoreModelState;

    TS_IsStationaryState  isStationaryState;

    TS_ObserveState  observeState;

    TS_Finish  finish;

    ScenarioFunctionID * actions;

}
 TestScenario;
String* getStateId_Default(Object * obj);
typedef bool (* PtrInit)(int, char * *);
typedef void (* PtrFinish)(void);
typedef Object* (* PtrGetState)(void);
typedef String* (* PtrGetStateId)(Object *);
typedef TestScenario dfsm;
bool start_dfsm(int  argc, char * * argv, dfsm * td);
typedef TestScenario ndfsm;
bool start_ndfsm(int  argc, char * * argv, ndfsm * test);
 typedef void Unit;

extern const Type type_Unit;


Unit* create_Unit();
typedef int c_bool;
void setTraceUserEnv(const char * name, const char * value);
void setTraceEncoding(const char * encoding);
void setTraceDataFormatXML();
void setTraceDataFormatString();
c_bool addTraceToConsole(void);
c_bool removeTraceToConsole(void);
c_bool addTraceToFile(const char * name);
c_bool removeTraceToFile(const char * name);
c_bool isTraceEnabled(void);
c_bool setTraceAccidental(c_bool  enable);
void startTrace(void);
void endTrace(void);
void traceScenarioStart(const char * name);
void traceScenarioParameters(int  argc, const char * * argv);
void traceTestEngineProperty(const char * name, const char * value);
void traceScenarioEnd(void);
void traceScenarioValue(const char * kind, const char * type, const char * name, const char * value);
void traceState(const char * id);
void traceTransitionStart(const char * id);
void traceTransitionEnd(void);
void traceModelOperationStart(const char * kind, const char * subsystem, const char * signature);
void traceModelOperationArgument(const char * type, const char * name, const char * value);
void traceModelOperationResult(const char * type, const char * value);
void traceModelOperationIdentifier(long  id);
void traceModelOperationChannel(long  chid);
void traceModelOperationTimestamp(const char * timestamp);
void traceOracleStart(const char * subsystem, const char * signature, long  refId);
void tracePreconditionEnd(void);
void traceOracleEnd(void);
void traceModelOperationEnd(void);
void traceSeriesStart(void);
void traceSeriesEnd(void);
void tracePrimeFormula(int  id, c_bool  value);
void traceCoverageElement(const char * structureId, const char * coverageId, int  branchId);
void traceMark(const char * mark);
void traceCoverageStructureStart(const char * name);
void traceFormulaeStart(void);
void traceFormula(int  id, const char * text);
void traceFormulaeEnd(void);
void traceCoverageStart(const char * id);
void traceElement(int  id, const char * name);
void traceCoverageEnd(void);
void traceCoverageStructureEnd(void);
void traceException(const char * kind);
void traceInterimException(const char * kind);
void traceExceptionValue(const char * name, const char * value);
void traceExceptionInfo(const char * info);
void traceInternalError(const char * info);
void traceSystemInfo(const char * info);
void traceUserInfo(const char * info);
void traceFormattedUserInfo(const char * format, ...);
c_bool isInTrace(void);
c_bool isInScenario(void);
c_bool isInTransition(void);
c_bool isInSeries(void);
c_bool isInModelOperation(void);
c_bool isInOracle(void);
c_bool isInPrecondition(void);
c_bool isInCoverageStructure(void);
c_bool isInFormulae(void);
c_bool isInCoverage(void);
int getTraceId(void);
void flushTrace(void);
void closeTrace(void);
typedef const char* CoverageText;
typedef int CoverageElement;
typedef enum 
{
    PRIMARY_COVERAGE, DOMAIN_VARIATION_COVERAGE, MULTIPLICATION_COVERAGE}

 COVERAGE_KIND;
typedef struct  _CoverageDesc
{
    COVERAGE_KIND  kind;

    int  size;

    int  base_num;

    int  order;

    bool  is_global;

    int  last_trace_id;

    CoverageText  name;

    CoverageElement  (* calc)();

    bool  (* filter)(CoverageElement);

    const void * data[];

}
 CoverageDesc;
extern int _CE_OUT_OF_COVERAGE;
const CoverageDesc* cov_component(const CoverageDesc * cov_desc, int  a);
CoverageElement ce_product(const CoverageDesc * cov_desc, ...);
CoverageElement ce_coord(const CoverageDesc * cov_desc, CoverageElement  element, int  axis, CoverageDesc * * p_prim_cov_desc);
CoverageText ce_txt(const CoverageDesc * cov_desc, CoverageElement  elem);
bool isElementInCoverage(const CoverageDesc * cov_desc, int  element);
void traceReachedCoverageElement(CoverageDesc * cov_desc, int  element);
void traceCoverageStructure(CoverageDesc * cov_desc);
const char* ts_get_ctesk_version(void);
const char* ts_get_ctesk_build(void);
void setBadVerdict(const char * msg);
bool isBadVerdict(void);
void clearBadVerdict(void);
enum  TS_Verdict
{
    TS_VERDICT_PRE = 1, TS_VERDICT_POST = 2, TS_VERDICT_MEDIATOR = 4, TS_VERDICT_SCENARIO = 8, TS_VERDICT_ALL = 15}

;
typedef void (* VerdictEventHandler)(bool  verdict);
void ts_set_verdict_event_handler(enum  TS_Verdict  ts_verdict_flags, VerdictEventHandler  handler);
void ts_fire_verdict_event(enum  TS_Verdict  ts_verdict_flag, bool  verdict);
bool start_stack_scenario(int argc,char** argv);

 typedef struct  List
 List;

extern const Type type_List;


 typedef struct  Set
 Set;

extern const Type type_Set;


Set* create_Set(const Type * elem_type);
Set* createCustomized_Set(const Type * elem_type, int  initialCapacity);
int size_Set(Set * self);
bool isEmpty_Set(Set * self);
bool contains_Set(Set * self, Object * ref);
bool add_Set(Set * self, Object * ref);
bool remove_Set(Set * self, Object * ref);
bool containsAll_Set(Set * self, Set * set);
bool addAll_Set(Set * self, Set * set);
bool retainAll_Set(Set * self, Set * set);
bool removeAll_Set(Set * self, Set * set);
void clear_Set(Set * self);
Object* get_Set(Set * self, int  index);
List* toList_Set(Set * self);
Type* elemType_Set(Set * self);
List* create_List(const Type * elem_type);
List* createCustomized_List(const Type * elem_type, int  initialCapacity);
void add_List(List * self, int  index, Object * ref);
void append_List(List * self, Object * ref);
void clear_List(List * self);
bool contains_List(List * self, Object * ref);
Object* get_List(List * self, int  index);
int indexOf_List(List * self, Object * ref);
bool isEmpty_List(List * self);
int lastIndexOf_List(List * self, Object * ref);
void remove_List(List * self, int  index);
void set_List(List * self, int  index, Object * ref);
int size_List(List * self);
List* subList_List(List * self, int  fromIndex, int  toIndex);
void addAll_List(List * self, int  index, List * other);
void appendAll_List(List * self, List * other);
Set* toSet_List(List * self);
Type* elemType_List(List * self);
extern  List* stck;
bool invariant_var_stck(void);
#ifndef PAR_RES_TYPE_push_spec_DEFINED
#define PAR_RES_TYPE_push_spec_DEFINED

struct PAR_RES_TYPE_push_spec
{
int inpar1;
int outpar1;
bool res;
};

typedef struct PAR_RES_TYPE_push_spec PAR_RES_TYPE_push_spec;
extern const Type type_PAR_RES_TYPE_push_spec;

#endif

#ifndef CONTEXT_TYPE_push_spec_DEFINED
#define CONTEXT_TYPE_push_spec_DEFINED

typedef
struct CONTEXT_TYPE_push_spec
{
  PAR_RES_TYPE_push_spec* params;
  TimeInterval  time;
  InteractionId refId;
} CONTEXT_TYPE_push_spec;

#endif

extern CONTEXT_TYPE_push_spec __context_push_spec;

#ifndef MEDIATOR_push_spec_DEFINED
#define MEDIATOR_push_spec_DEFINED
  typedef bool (*MEDIATOR_FUNC_push_spec)( CallProperties*, int i );
  typedef struct MEDIATOR_push_spec
   {
    MEDIATOR_FUNC_push_spec sequential_mediator;
    MEDIATOR_FUNC_push_spec call_mediator;
    MEDIATOR_FUNC_push_spec parallel_mediator;
   } 
  MEDIATOR_push_spec;
#endif

MEDIATOR_push_spec set_mediator_push_spec( MEDIATOR_push_spec m );

bool pre_push_spec( int i );

bool oracle_push_spec( MEDIATOR_FUNC_push_spec __media, OracleCallProperties* __oracle_properties, int i );

OracleVerdict call_pure_oracle_push_spec( CONTEXT_TYPE_push_spec context );

bool call_active_oracle_push_spec( int i );

extern SpecificationID push_spec;

#ifndef PAR_RES_TYPE_pop_spec_DEFINED
#define PAR_RES_TYPE_pop_spec_DEFINED

struct PAR_RES_TYPE_pop_spec
{
int *inpar1;
int *outpar1;
bool res;
};

typedef struct PAR_RES_TYPE_pop_spec PAR_RES_TYPE_pop_spec;
extern const Type type_PAR_RES_TYPE_pop_spec;

#endif

#ifndef CONTEXT_TYPE_pop_spec_DEFINED
#define CONTEXT_TYPE_pop_spec_DEFINED

typedef
struct CONTEXT_TYPE_pop_spec
{
  PAR_RES_TYPE_pop_spec* params;
  TimeInterval  time;
  InteractionId refId;
} CONTEXT_TYPE_pop_spec;

#endif

extern CONTEXT_TYPE_pop_spec __context_pop_spec;

#ifndef MEDIATOR_pop_spec_DEFINED
#define MEDIATOR_pop_spec_DEFINED
  typedef bool (*MEDIATOR_FUNC_pop_spec)( CallProperties*, int *item );
  typedef struct MEDIATOR_pop_spec
   {
    MEDIATOR_FUNC_pop_spec sequential_mediator;
    MEDIATOR_FUNC_pop_spec call_mediator;
    MEDIATOR_FUNC_pop_spec parallel_mediator;
   } 
  MEDIATOR_pop_spec;
#endif

MEDIATOR_pop_spec set_mediator_pop_spec( MEDIATOR_pop_spec m );

bool pre_pop_spec( int *item );

bool oracle_pop_spec( MEDIATOR_FUNC_pop_spec __media, OracleCallProperties* __oracle_properties, int *item );

OracleVerdict call_pure_oracle_pop_spec( CONTEXT_TYPE_pop_spec context );

bool call_active_oracle_pop_spec( int *item );

extern SpecificationID pop_spec;

typedef struct 
{
    int * elems;

    size_t  size;

    size_t  capacity;

}
 stack;
stack* create_stack(size_t  size);
void delete_stack(stack * stck);
int push(stack * stck, int  e);
int pop(stack * stck, int *const e);
int is_empty(stack * stck);
int is_full(stack * stck);
size_t how_much(stack * stck);
extern stack* impl_stack;
extern MEDIATOR_push_spec push_media;

extern MEDIATOR_pop_spec pop_media;

 typedef signed int Integer;

extern const Type type_Integer;


 typedef unsigned int UInteger;

extern const Type type_UInteger;


Integer* create_Integer(int  i);
UInteger* create_UInteger(unsigned int  i);
int value_Integer(Integer * i);
unsigned int value_UInteger(UInteger * i);
bool initStack(int  argc, char * * argv)

{
    bool __res;
    int __up = 0, __cmd = -3;
    _dummy( &__up ); _dummy( &__cmd );
    {
        impl_stack = create_stack(10);

        ts_assign_spec_ref(
            (Object**)&(stck),
            (create_List(&type_Integer)),
            "stack_scenario.sec(32,8)"
                          );

        set_mediator_push_spec(push_media);

        set_mediator_pop_spec(pop_media);

        { __res = (1); goto __destroy_body; }


    }

goto __destroy_body;
__destroy_body:;
    return __res;
}
void finishStack()

{
    int __up = 0, __cmd = -3;
    _dummy( &__up ); _dummy( &__cmd );
    {
        ts_assign_spec_ref(
            (Object**)&(stck),
            ts_check_spec_ref( &type_List, (((void *)0)), "assignment to stck", "stack_scenario.sec(46,8)" ),
            "stack_scenario.sec(46,8)"
                          );

        delete_stack(impl_stack);


    }

}
Integer* stateStack()

{
    Integer *__res = (void*)0;
    int __up = 0, __cmd = -3;
    _dummy( &__up ); _dummy( &__cmd );
    {
        { __res = (create_Integer(size_List(r(stck)))); goto __destroy_body; }


    }

goto __destroy_body;
__destroy_body:;
    ts_check_spec_ref( &type_Integer
                     , __res
                     , "returned value of stateStack"
                     , (void*)0
                     );
    return __res;
}
static SimpleTypeDesc __type_desc__int;

struct __push_scen_Par
{
    int index;
    int flags;
    int i_0;
    int i_0_init;
    int i_0_used;
};

static void init___push_scen_Par( struct __push_scen_Par *_tmp_par, va_list *arg_list )
{
    memset( _tmp_par, 0, sizeof( *_tmp_par ) );
}

typedef struct __push_scen_Par __push_scen_Par;
static StructTypeDesc __type_desc__struct___push_scen_Par;

static int compare___push_scen_Par( struct __push_scen_Par *left, struct __push_scen_Par *right )
{
    if( ts_equals_sectype( (SECTypeDesc*)&__type_desc__struct___push_scen_Par, left, right ) )
      return 0;
    return 1;
}

static String* to_string___push_scen_Par( struct __push_scen_Par *obj )
{
    return ts_to_string_sectype( (SECTypeDesc*)&__type_desc__struct___push_scen_Par, obj );
}

static String* to_XML___push_scen_Par( struct __push_scen_Par *obj )
{
    return ts_to_XML_sectype( (SECTypeDesc*)&__type_desc__struct___push_scen_Par, obj );
}

const Type type___push_scen_Par =
{
  "__push_scen_Par",
  sizeof(struct __push_scen_Par),
  &type_Object,
  (Init)init___push_scen_Par,
  (Copy)copy_Default,
  (Compare)compare___push_scen_Par,
  (ToString)to_string___push_scen_Par,
  (ToXML)to_XML___push_scen_Par,
  (CheckInvariant)check_invariant_Default,
  (Enumerate)enumerate_Default,
  (Destroy)destroy_Default
};

Object *__push_scen_init( void )
{
    __push_scen_Par *_tmp_par = (__push_scen_Par *)create( &type___push_scen_Par );
    _tmp_par->index = -1;
    _tmp_par->flags = 0;
    return (Object *)_tmp_par;
}

bool __push_scen_hasNext( Object *__par )
{
    __push_scen_Par *_tmp_par = (__push_scen_Par *)__par;
    bool has_next = 0;

    has_next =    has_next
               || (    _tmp_par->i_0_init
                    && _tmp_par->i_0_used
                  )
             ;

    destroy( _tmp_par );
    return has_next;
}

bool __push_scen_call( Object *__par )
{
    __push_scen_Par *_tmp_par = (__push_scen_Par *)__par;

    bool __res = 1;
    int __tmp = 0;
    int __up = 0, __cmd = -3;
    _dummy( &__up ); _dummy( &__cmd );
    _dummy( &__tmp );
    _tmp_par->index++;
    clearOracleVerdict();
    {
        String *__str;

        bool i_0_was_used = _tmp_par->i_0_used;
        _dummy( &i_0_was_used );
        _tmp_par->i_0_used = 0;

        {
            // start of iteration statement
            {
                _tmp_par->i_0_used = 1;

                if( !(_tmp_par->flags & 1) )
                {
                    // init iterate variable 'i'
                    if( !_tmp_par->i_0_init )
                    {
                        int  __tmp_var = 0;
                        ts_copy_sectype( (SECTypeDesc*)&__type_desc__int
                                       , &_tmp_par->i_0
                                       , &__tmp_var
                                       , 1
                                       );
                        if( !(_tmp_par->i_0 < 10) ) goto __end_iteration_0;
                        _tmp_par->i_0_init = 1;
                    }
                    // next for iterate variable 'i'
                    else
                    {
                        _tmp_par->i_0++;
                        if (!(_tmp_par->i_0 < 10)) goto __end_iterating_0;
                    }
                }
                if( !(_tmp_par->flags & 2) )
                {
                    __str = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__int, &_tmp_par->i_0 );
                    traceScenarioValue( "iteration variable"
                                      , "int"
                                      , "i"
                                      , toCharArray_String( r( __str ) )
                                      );
                    destroy( __str );
                }
                {
                    call_active_oracle_push_spec(_tmp_par->i_0);


                }

                goto __end_iteration_0;
            __end_iterating_0:;
                _tmp_par->i_0_init = 0;
            __end_iteration_0:;
            }

            {
              __res = (1);
              goto __destroy_body;
            }


        }

    }
goto __destroy_body;
__destroy_body:;

    if( !__res )
    {
        traceException( SCENARIO_FUNCTION_FAILED_MESSAGE );
    }
    destroy( _tmp_par );
    return __res && getOracleVerdict();
}

bool __push_scen_next( Object *__par )
{
    __push_scen_Par *_tmp_par = (__push_scen_Par *)__par;
    _tmp_par->flags |= 2;
    __push_scen_call( r(_tmp_par) );
    _tmp_par->flags &= ~2;
    return __push_scen_hasNext( _tmp_par );
}

ScenarioFunctionDesc push_scen =
{
    &__push_scen_init,
    &__push_scen_hasNext,
    &__push_scen_next,
    &__push_scen_call,
    "push_scen"
};

static int item;
struct __pop_scen_Par
{
    int index;
    int flags;
};

static void init___pop_scen_Par( struct __pop_scen_Par *_tmp_par, va_list *arg_list )
{
    memset( _tmp_par, 0, sizeof( *_tmp_par ) );
}

typedef struct __pop_scen_Par __pop_scen_Par;
static StructTypeDesc __type_desc__struct___pop_scen_Par;

static int compare___pop_scen_Par( struct __pop_scen_Par *left, struct __pop_scen_Par *right )
{
    if( ts_equals_sectype( (SECTypeDesc*)&__type_desc__struct___pop_scen_Par, left, right ) )
      return 0;
    return 1;
}

static String* to_string___pop_scen_Par( struct __pop_scen_Par *obj )
{
    return ts_to_string_sectype( (SECTypeDesc*)&__type_desc__struct___pop_scen_Par, obj );
}

static String* to_XML___pop_scen_Par( struct __pop_scen_Par *obj )
{
    return ts_to_XML_sectype( (SECTypeDesc*)&__type_desc__struct___pop_scen_Par, obj );
}

const Type type___pop_scen_Par =
{
  "__pop_scen_Par",
  sizeof(struct __pop_scen_Par),
  &type_Object,
  (Init)init___pop_scen_Par,
  (Copy)copy_Default,
  (Compare)compare___pop_scen_Par,
  (ToString)to_string___pop_scen_Par,
  (ToXML)to_XML___pop_scen_Par,
  (CheckInvariant)check_invariant_Default,
  (Enumerate)enumerate_Default,
  (Destroy)destroy_Default
};

Object *__pop_scen_init( void )
{
    __pop_scen_Par *_tmp_par = (__pop_scen_Par *)create( &type___pop_scen_Par );
    _tmp_par->index = -1;
    _tmp_par->flags = 0;
    return (Object *)_tmp_par;
}

bool __pop_scen_hasNext( Object *__par )
{
    __pop_scen_Par *_tmp_par = (__pop_scen_Par *)__par;
    bool has_next = 0;


    destroy( _tmp_par );
    return has_next;
}

bool __pop_scen_call( Object *__par )
{
    __pop_scen_Par *_tmp_par = (__pop_scen_Par *)__par;

    bool __res = 1;
    int __tmp = 0;
    int __up = 0, __cmd = -3;
    _dummy( &__up ); _dummy( &__cmd );
    _dummy( &__tmp );
    _tmp_par->index++;
    clearOracleVerdict();
    {


        {
            call_active_oracle_pop_spec(&item);

            {
              __res = (1);
              goto __destroy_body;
            }


        }

    }
goto __destroy_body;
__destroy_body:;

    if( !__res )
    {
        traceException( SCENARIO_FUNCTION_FAILED_MESSAGE );
    }
    destroy( _tmp_par );
    return __res && getOracleVerdict();
}

bool __pop_scen_next( Object *__par )
{
    __pop_scen_Par *_tmp_par = (__pop_scen_Par *)__par;
    bool res = ++_tmp_par->index == 0;
    destroy( _tmp_par );
    return res;
}

ScenarioFunctionDesc pop_scen =
{
    &__pop_scen_init,
    &__pop_scen_hasNext,
    &__pop_scen_next,
    &__pop_scen_call,
    "pop_scen"
};

static ScenarioFunctionID __externalized_array_0[] =
{
    &push_scen,
    &pop_scen,
    ((void *)0)}
;

dfsm stack_scenario = {
      "stack_scenario"
    , (PtrInit)initStack
    , (PtrGetState)stateStack
    , (void*)0
    , (void*)0
    , (void*)0
    , (void*)0
    , (void*)0
    , (PtrFinish)finishStack
    , __externalized_array_0
}
;

bool start_stack_scenario( int argc, char** argv )
{
    return start_dfsm( argc, argv, &stack_scenario );
}



static SimpleTypeDesc __type_desc__int =
{ simpleType
, ((void*)0)
, ((void*)0)
, "int"
, sizeof (int)
, "  d"
};






static FieldDesc __fields_desc__struct___push_scen_Par[] = 
{
    { "index", ((char*)(&((struct __push_scen_Par*)0)->index) - (char*)0), (SECTypeDesc*)&__type_desc__int },
    { "flags", ((char*)(&((struct __push_scen_Par*)0)->flags) - (char*)0), (SECTypeDesc*)&__type_desc__int },
    { "i_0", ((char*)(&((struct __push_scen_Par*)0)->i_0) - (char*)0), (SECTypeDesc*)&__type_desc__int },
    { "i_0_init", ((char*)(&((struct __push_scen_Par*)0)->i_0_init) - (char*)0), (SECTypeDesc*)&__type_desc__int },
    { "i_0_used", ((char*)(&((struct __push_scen_Par*)0)->i_0_used) - (char*)0), (SECTypeDesc*)&__type_desc__int }
};

static StructTypeDesc __type_desc__struct___push_scen_Par = 
{ structType
, ((void*)0)
, ((void*)0)
, "struct __push_scen_Par"
, sizeof( struct __push_scen_Par )
, 5
, __fields_desc__struct___push_scen_Par
};








static FieldDesc __fields_desc__struct___pop_scen_Par[] = 
{
    { "index", ((char*)(&((struct __pop_scen_Par*)0)->index) - (char*)0), (SECTypeDesc*)&__type_desc__int },
    { "flags", ((char*)(&((struct __pop_scen_Par*)0)->flags) - (char*)0), (SECTypeDesc*)&__type_desc__int }
};

static StructTypeDesc __type_desc__struct___pop_scen_Par = 
{ structType
, ((void*)0)
, ((void*)0)
, "struct __pop_scen_Par"
, sizeof( struct __pop_scen_Par )
, 2
, __fields_desc__struct___pop_scen_Par
};



