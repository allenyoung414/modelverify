/******************************************************************************/
/**                                                                          **/
/**  Generated by: sec 2.9.315-beta-110124                                   **/
/**  Date: Fri May 17 15:38:19 CST 2024                                      **/
/**                                                                          **/
/******************************************************************************/


#define va_start(ap,v)  __builtin_va_start(ap,v)
#define va_end(ap)      __builtin_va_end(ap)
#define va_arg(ap,t)    __builtin_va_arg(ap,t)

typedef void Object;
void _dummy( void * );

typedef long unsigned int size_t;
extern void* memcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern void* memmove(void * __dest, const void * __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern void* memset(void * __s, int  __c, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern int memcmp(const void * __s1, const void * __s2, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern void* memchr(const void * __s, int  __c, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern char* strcpy(char *__restrict__ __dest, const char *__restrict__ __src) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strcat(char *__restrict__ __dest, const char *__restrict__ __src) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strncat(char *__restrict__ __dest, const char *__restrict__ __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern int strcmp(const char * __s1, const char * __s2) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern int strncmp(const char * __s1, const char * __s2, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern int strcoll(const char * __s1, const char * __s2) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern size_t strxfrm(char *__restrict__ __dest, const char *__restrict__ __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 2 )));
extern char* strchr(const char * __s, int  __c) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern char* strrchr(const char * __s, int  __c) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern size_t strcspn(const char * __s, const char * __reject) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern size_t strspn(const char * __s, const char * __accept) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strpbrk(const char * __s, const char * __accept) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strstr(const char * __haystack, const char * __needle) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strtok(char *__restrict__ __s, const char *__restrict__ __delim) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 2 )));
extern char* __strtok_r(char *__restrict__ __s, const char *__restrict__ __delim, char * *__restrict__ __save_ptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 2, 3 )));
extern size_t strlen(const char * __s) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern char* strerror(int  __errnum) __attribute__(( __nothrow__, __leaf__));
typedef char bool;
typedef __builtin_va_list __gnuc_va_list;
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
typedef signed long int __int64_t;
typedef unsigned long int __uint64_t;
typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;
typedef long int __quad_t;
typedef unsigned long int __u_quad_t;
typedef long int __intmax_t;
typedef unsigned long int __uintmax_t;
typedef unsigned long int __dev_t;
typedef unsigned int __uid_t;
typedef unsigned int __gid_t;
typedef unsigned long int __ino_t;
typedef unsigned long int __ino64_t;
typedef unsigned int __mode_t;
typedef unsigned long int __nlink_t;
typedef long int __off_t;
typedef long int __off64_t;
typedef int __pid_t;
typedef struct 
{
    int  __val[2];

}
 __fsid_t;
typedef long int __clock_t;
typedef unsigned long int __rlim_t;
typedef unsigned long int __rlim64_t;
typedef unsigned int __id_t;
typedef long int __time_t;
typedef unsigned int __useconds_t;
typedef long int __suseconds_t;
typedef int __daddr_t;
typedef int __key_t;
typedef int __clockid_t;
typedef void* __timer_t;
typedef long int __blksize_t;
typedef long int __blkcnt_t;
typedef long int __blkcnt64_t;
typedef unsigned long int __fsblkcnt_t;
typedef unsigned long int __fsblkcnt64_t;
typedef unsigned long int __fsfilcnt_t;
typedef unsigned long int __fsfilcnt64_t;
typedef long int __fsword_t;
typedef long int __ssize_t;
typedef long int __syscall_slong_t;
typedef unsigned long int __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char* __caddr_t;
typedef long int __intptr_t;
typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
typedef struct 
{
    int  __count;

    union 
    {
        unsigned int  __wch;

        char  __wchb[4];

    }
      __value;

}
 __mbstate_t;
typedef struct  _G_fpos_t
{
    __off_t  __pos;

    __mbstate_t  __state;

}
 __fpos_t;
typedef struct  _G_fpos64_t
{
    __off64_t  __pos;

    __mbstate_t  __state;

}
 __fpos64_t;
struct  _IO_FILE
;
typedef struct  _IO_FILE
 __FILE;
struct  _IO_FILE
;
typedef struct  _IO_FILE
 FILE;
struct  _IO_FILE
;
struct  _IO_marker
;
struct  _IO_codecvt
;
struct  _IO_wide_data
;
typedef void _IO_lock_t;
struct  _IO_FILE
{
    int  _flags;

    char * _IO_read_ptr;

    char * _IO_read_end;

    char * _IO_read_base;

    char * _IO_write_base;

    char * _IO_write_ptr;

    char * _IO_write_end;

    char * _IO_buf_base;

    char * _IO_buf_end;

    char * _IO_save_base;

    char * _IO_backup_base;

    char * _IO_save_end;

    struct  _IO_marker
     * _markers;

    struct  _IO_FILE
     * _chain;

    int  _fileno;

    int  _flags2;

    __off_t  _old_offset;

    unsigned short  _cur_column;

    signed char  _vtable_offset;

    char  _shortbuf[1];

    _IO_lock_t * _lock;

    __off64_t  _offset;

    struct  _IO_codecvt
     * _codecvt;

    struct  _IO_wide_data
     * _wide_data;

    struct  _IO_FILE
     * _freeres_list;

    void * _freeres_buf;

    size_t  __pad5;

    int  _mode;

    char  _unused2[15 * sizeof( int ) - 4 * sizeof( void * ) - sizeof( size_t )];

}
;
typedef __fpos_t fpos_t;
extern FILE* stdin;
extern FILE* stdout;
extern FILE* stderr;
extern int remove(const char * __filename) __attribute__(( __nothrow__, __leaf__));
extern int rename(const char * __old, const char * __new) __attribute__(( __nothrow__, __leaf__));
extern FILE* tmpfile(void);
extern char* tmpnam(char * __s) __attribute__(( __nothrow__, __leaf__));
extern int fclose(FILE * __stream);
extern int fflush(FILE * __stream);
extern FILE* fopen(const char *__restrict__ __filename, const char *__restrict__ __modes);
extern FILE* freopen(const char *__restrict__ __filename, const char *__restrict__ __modes, FILE *__restrict__ __stream);
extern void setbuf(FILE *__restrict__ __stream, char *__restrict__ __buf) __attribute__(( __nothrow__, __leaf__));
extern int setvbuf(FILE *__restrict__ __stream, char *__restrict__ __buf, int  __modes, size_t  __n) __attribute__(( __nothrow__, __leaf__));
extern int fprintf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...);
extern int printf(const char *__restrict__ __format, ...);
extern int sprintf(char *__restrict__ __s, const char *__restrict__ __format, ...) __attribute__(( __nothrow__));
extern int vfprintf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg);
extern int vprintf(const char *__restrict__ __format, __gnuc_va_list  __arg);
extern int vsprintf(char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __nothrow__));
extern int snprintf(char *__restrict__ __s, size_t  __maxlen, const char *__restrict__ __format, ...) __attribute__(( __nothrow__)) __attribute__(( __format__( __printf__, 3, 4 )));
extern int vsnprintf(char *__restrict__ __s, size_t  __maxlen, const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __nothrow__)) __attribute__(( __format__( __printf__, 3, 0 )));
extern int fscanf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...);
extern int scanf(const char *__restrict__ __format, ...);
extern int sscanf(const char *__restrict__ __s, const char *__restrict__ __format, ...) __attribute__(( __nothrow__, __leaf__));
extern int fscanf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...) __asm__(  """__isoc99_fscanf");
extern int scanf(const char *__restrict__ __format, ...) __asm__(  """__isoc99_scanf");
extern int sscanf(const char *__restrict__ __s, const char *__restrict__ __format, ...) __asm__(  """__isoc99_sscanf") __attribute__(( __nothrow__, __leaf__));
extern int vfscanf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __format__( __scanf__, 2, 0 )));
extern int vscanf(const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __format__( __scanf__, 1, 0 )));
extern int vsscanf(const char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __format__( __scanf__, 2, 0 )));
extern int vfscanf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __asm__(  """__isoc99_vfscanf") __attribute__(( __format__( __scanf__, 2, 0 )));
extern int vscanf(const char *__restrict__ __format, __gnuc_va_list  __arg) __asm__(  """__isoc99_vscanf") __attribute__(( __format__( __scanf__, 1, 0 )));
extern int vsscanf(const char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __asm__(  """__isoc99_vsscanf") __attribute__(( __nothrow__, __leaf__)) __attribute__(( __format__( __scanf__, 2, 0 )));
extern int fgetc(FILE * __stream);
extern int getc(FILE * __stream);
extern int getchar(void);
extern int fputc(int  __c, FILE * __stream);
extern int putc(int  __c, FILE * __stream);
extern int putchar(int  __c);
extern char* fgets(char *__restrict__ __s, int  __n, FILE *__restrict__ __stream);
extern char* gets(char * __s) __attribute__(( __deprecated__));
extern int fputs(const char *__restrict__ __s, FILE *__restrict__ __stream);
extern int puts(const char * __s);
extern int ungetc(int  __c, FILE * __stream);
extern size_t fread(void *__restrict__ __ptr, size_t  __size, size_t  __n, FILE *__restrict__ __stream);
extern size_t fwrite(const void *__restrict__ __ptr, size_t  __size, size_t  __n, FILE *__restrict__ __s);
extern int fseek(FILE * __stream, long int  __off, int  __whence);
extern long int ftell(FILE * __stream);
extern void rewind(FILE * __stream);
extern int fgetpos(FILE *__restrict__ __stream, fpos_t *__restrict__ __pos);
extern int fsetpos(FILE * __stream, const fpos_t * __pos);
extern void clearerr(FILE * __stream) __attribute__(( __nothrow__, __leaf__));
extern int feof(FILE * __stream) __attribute__(( __nothrow__, __leaf__));
extern int ferror(FILE * __stream) __attribute__(( __nothrow__, __leaf__));
extern void perror(const char * __s);
extern int __uflow(FILE *);
extern int __overflow(FILE *, int);
typedef int wchar_t;
typedef struct 
{
    int  quot;

    int  rem;

}
 div_t;
typedef struct 
{
    long int  quot;

    long int  rem;

}
 ldiv_t;
__extension__ typedef struct 
{
    long long int  quot;

    long long int  rem;

}
 lldiv_t;
extern size_t __ctype_get_mb_cur_max(void) __attribute__(( __nothrow__, __leaf__));
extern double atof(const char * __nptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern int atoi(const char * __nptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern long int atol(const char * __nptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
__extension__ extern long long int atoll(const char * __nptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern double strtod(const char *__restrict__ __nptr, char * *__restrict__ __endptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern float strtof(const char *__restrict__ __nptr, char * *__restrict__ __endptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern long double strtold(const char *__restrict__ __nptr, char * *__restrict__ __endptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern long int strtol(const char *__restrict__ __nptr, char * *__restrict__ __endptr, int  __base) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern unsigned long int strtoul(const char *__restrict__ __nptr, char * *__restrict__ __endptr, int  __base) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
__extension__ extern long long int strtoll(const char *__restrict__ __nptr, char * *__restrict__ __endptr, int  __base) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
__extension__ extern unsigned long long int strtoull(const char *__restrict__ __nptr, char * *__restrict__ __endptr, int  __base) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern int rand(void) __attribute__(( __nothrow__, __leaf__));
extern void srand(unsigned int  __seed) __attribute__(( __nothrow__, __leaf__));
extern void* malloc(size_t  __size) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __malloc__)) __attribute__(( __alloc_size__( 1 )));
extern void* calloc(size_t  __nmemb, size_t  __size) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __malloc__)) __attribute__(( __alloc_size__( 1, 2 )));
extern void* realloc(void * __ptr, size_t  __size) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __warn_unused_result__)) __attribute__(( __alloc_size__( 2 )));
extern void free(void * __ptr) __attribute__(( __nothrow__, __leaf__));
extern void abort(void) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __noreturn__));
extern int atexit(void  (* __func)(void)) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern void exit(int  __status) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __noreturn__));
extern void _Exit(int  __status) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __noreturn__));
extern char* getenv(const char * __name) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern int system(const char * __command);
typedef int (* __compar_fn_t)(const void *, const void *);
extern void* bsearch(const void * __key, const void * __base, size_t  __nmemb, size_t  __size, __compar_fn_t  __compar) __attribute__(( __nonnull__( 1, 2, 5 )));
extern void qsort(void * __base, size_t  __nmemb, size_t  __size, __compar_fn_t  __compar) __attribute__(( __nonnull__( 1, 4 )));
extern int abs(int  __x) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern long int labs(long int  __x) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
__extension__ extern long long int llabs(long long int  __x) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern div_t div(int  __numer, int  __denom) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern ldiv_t ldiv(long int  __numer, long int  __denom) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
__extension__ extern lldiv_t lldiv(long long int  __numer, long long int  __denom) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern int mblen(const char * __s, size_t  __n) __attribute__(( __nothrow__, __leaf__));
extern int mbtowc(wchar_t *__restrict__ __pwc, const char *__restrict__ __s, size_t  __n) __attribute__(( __nothrow__, __leaf__));
extern int wctomb(char * __s, wchar_t  __wchar) __attribute__(( __nothrow__, __leaf__));
extern size_t mbstowcs(wchar_t *__restrict__ __pwcs, const char *__restrict__ __s, size_t  __n) __attribute__(( __nothrow__, __leaf__));
extern size_t wcstombs(char *__restrict__ __s, const wchar_t *__restrict__ __pwcs, size_t  __n) __attribute__(( __nothrow__, __leaf__));
typedef __gnuc_va_list va_list;
typedef void (* AssertionExit)(const char * format, va_list  args);
AssertionExit atAssertion(AssertionExit  func);
AssertionExit atFault(AssertionExit  func);
bool isCustomAssertionExit(void);
void assertion(int  expr, const char * format, ...);
void fault(int  expr, const char * format, ...);
typedef long int ptrdiff_t;
typedef struct  Type
 Type;
 typedef struct  String
 String;

extern const Type type_String;


String* create_String(const char * cstr);
char charAt_String(String * self, int  index);
String* concat_String(String * self, String * str);
bool endsWith_String(String * self, String * suffix);
int indexOfChar_String(String * self, int  ch);
int indexOfCharFrom_String(String * self, int  ch, int  fromIndex);
int indexOfString_String(String * self, String * str);
int indexOfStringFrom_String(String * self, String * str, int  fromIndex);
int lastIndexOfChar_String(String * self, int  ch);
int lastIndexOfCharFrom_String(String * self, int  ch, int  fromIndex);
int lastIndexOfString_String(String * self, String * str);
int lastIndexOfStringFrom_String(String * self, String * str, int  fromIndex);
int length_String(String * self);
bool regionMatches_String(String * self, bool  ignoreCase, int  toffset, String * other, int  ooffset, int  len);
bool regionMatchesCase_String(String * self, int  toffset, String * other, int  ooffset, int  len);
String* replace_String(String * self, char  oldChar, char  newChar);
bool startsWith_String(String * self, String * prefix);
bool startsWithOffset_String(String * self, String * prefix, int  toffset);
String* substringFrom_String(String * self, int  beginIndex);
String* substring_String(String * self, int  beginIndex, int  endIndex);
const char* toCharArray_String(String * self);
String* toLowerCase_String(String * self);
String* toUpperCase_String(String * self);
String* trim_String(String * self);
String* format_String(const char * format, ...);
String* vformat_String(const char * format, va_list  args);
String* valueOfBool_String(bool  b);
String* valueOfChar_String(char  c);
String* valueOfShort_String(short  i);
String* valueOfUShort_String(unsigned short  i);
String* valueOfInt_String(int  i);
String* valueOfUInt_String(unsigned int  i);
String* valueOfLong_String(long  l);
String* valueOfULong_String(unsigned long  l);
String* valueOfFloat_String(float  f);
String* valueOfDouble_String(double  d);
String* valueOfPtr_String(void * p);
String* valueOfObject_String(Object * ref);
String* valueOfBytes_String(const char * p, int  l);
String* XML_encode_String(String * self);
int hash_String(String * str);
Object* r(Object * ref);
Object* r_weak(Object * ref);
Object* r_hard(Object * ref);
Object* r_hard2weak(Object * ref);
Object* r_weak2hard(Object * ref);
void r_take(Object * ref);
void r_release(Object * ref);
typedef void (* Init)(void * ref, va_list * arg_list);
typedef void (* Copy)(void * src, void * dst);
typedef int (* Compare)(void * left, void * right);
typedef String* (* ToString)(void * ref);
typedef String* (* ToXML)(void * ref);
typedef bool (* CheckInvariant)(Object * ref);
typedef bool (* EnumerationCallbackFuncType)(void * ref, void * par);
typedef void (* Enumerate)(void * ref, EnumerationCallbackFuncType  callback, void * par);
typedef void (* Destroy)(void * ref);
struct  Type
{
    const char * name;

    size_t  size;

    const Type * base;

    Init  init;

    Copy  copy;

    Compare  compare;

    ToString  to_string;

    ToXML  to_XML;

    CheckInvariant  check_invariant;

    Enumerate  enumerate;

    Destroy  destroy;

}
;
extern const Type type_Object;
const Type* type(Object * ref);
const Type* TYPE(Object * ref);
size_t size_Type(const Type * type);
bool isBasicType(const Type * type1, const Type * type2);
const Type* getMaximalType(const Type * type);
Object* create_Object(const Type *, ...);
Object* va_create_Object(const Type *, va_list * arg_list);
Object* create(const Type *, ...);
Object* va_create(const Type *, va_list * arg_list);
Object* clone_Object(Object * ref);
Object* clone(Object * ref);
void set_Object(Object * ref, ...);
void set(Object * ref, ...);
void copy_Object(Object * src, Object * dst);
void copy(Object * src, Object * dst);
int compare_Object(Object * left, Object * right);
int compare(Object * left, Object * right);
bool equals_Object(Object * self, Object * ref);
bool equals(Object * self, Object * ref);
String* toString_Object(Object * ref);
String* toString(Object * ref);
String* toTrace(Object * ref);
String* toXML_Object(Object * ref);
String* toXML(Object * ref);
String* to_XML_spec(const char * type, String * value);
String* toTrace(Object * ref);
bool checkInvariant_Object(Object * ref);
bool checkInvariant(Object * ref);
void detach_Object(Object * ref);
void destroy_Object(Object * ref);
void destroy(Object * ref);
void init_Default(Object * ref, va_list * arg_list);
void copy_Default(Object * src, Object * dst);
int compare_Default(Object * left, Object * right);
String* to_string_Default(Object * ref);
String* to_XML_Default(Object * ref);
bool check_invariant_Default(Object * ref);
void enumerate_Default(Object * ref, EnumerationCallbackFuncType  callback, void * par);
void destroy_Default(Object * ref);
void init_Subtype(Object * ref, va_list * arg_list);
void copy_Subtype(Object * src, Object * dst);
int compare_Subtype(Object * left, Object * right);
String* to_string_Subtype(Object * ref);
String* to_XML_Subtype(Object * ref);
void enumerate_Subtype(Object * ref, EnumerationCallbackFuncType  callback, void * par);
void destroy_Subtype(Object * ref);
typedef enum  SECTypeKind
{
    simpleType, structType, pointerType, arrayType, specType, subType}

 SECTypeKind;
typedef struct  SECTypeDesc
 SECTypeDesc;
struct  SECTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

}
;
typedef struct  SimpleTypeDesc
 SimpleTypeDesc;
struct  SimpleTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    const char * name;

    size_t  sizeOf;

    const char * format;

}
;
typedef struct  FieldDesc
 FieldDesc;
struct  FieldDesc
{
    const char * name;

    unsigned int  offset;

    SECTypeDesc * type_desc;

}
;
typedef struct  StructTypeDesc
 StructTypeDesc;
struct  StructTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    const char * name;

    size_t  sizeOf;

    int  numFields;

    FieldDesc * fields;

}
;
typedef struct  PointerTypeDesc
 PointerTypeDesc;
struct  PointerTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    int  level;

    SECTypeDesc * base;

}
;
typedef struct  ArrayTypeDesc
 ArrayTypeDesc;
struct  ArrayTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    size_t  sizeOfElement;

    int  numElements;

    SECTypeDesc * base;

}
;
typedef struct  SpecTypeDesc
 SpecTypeDesc;
struct  SpecTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    const Type * type;

}
;
typedef bool (* InvariantCheckerPtr)(void *);
typedef struct  SubTypeDesc
 SubTypeDesc;
struct  SubTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    const char * name;

    SECTypeDesc * base;

    InvariantCheckerPtr  invariant_checker;

}
;
SECTypeDesc* ts_base_type_desc(SECTypeDesc * type_desc);
void ts_start_copy_sectype();
void ts_copy_sectype(SECTypeDesc * desc, void * dst, void * src, bool  weak);
void ts_finish_copy_sectype();
bool ts_equals_sectype(SECTypeDesc * desc, void * left, void * right);
String* ts_to_string_sectype(SECTypeDesc * desc, void * ptr);
String* ts_to_XML_sectype(SECTypeDesc * desc, void * ptr);
String* ts_to_trace_sectype(SECTypeDesc * desc, void * ptr);
bool ts_start_to_XML();
String* create_single_XML_entry(const char * kind, const char * type, String * value);
void ts_finish_to_XML();
bool ts_check_invariant_sectype(SECTypeDesc * desc, void * ptr);
void ts_enumerate_sectype(SECTypeDesc * desc, void * ptr, EnumerationCallbackFuncType  callback, void * par);
void ts_start_destroy_sectype();
void ts_destroy_sectype(SECTypeDesc * desc, void * ptr, bool  weak);
void ts_finish_destroy_sectype();
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef __int_least8_t int_least8_t;
typedef __int_least16_t int_least16_t;
typedef __int_least32_t int_least32_t;
typedef __int_least64_t int_least64_t;
typedef __uint_least8_t uint_least8_t;
typedef __uint_least16_t uint_least16_t;
typedef __uint_least32_t uint_least32_t;
typedef __uint_least64_t uint_least64_t;
typedef signed char int_fast8_t;
typedef long int int_fast16_t;
typedef long int int_fast32_t;
typedef long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned long int uint_fast16_t;
typedef unsigned long int uint_fast32_t;
typedef unsigned long int uint_fast64_t;
typedef long int intptr_t;
typedef unsigned long int uintptr_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef long ChannelID;
extern const ChannelID WrongChannel;
extern const ChannelID UniqueChannel;
ChannelID getChannelID(void);
void releaseChannelID(ChannelID  chid);
typedef uint64_t LinearTimeMark;
typedef int TimeFrameOfReferenceID;
extern const TimeFrameOfReferenceID infiniteTimeFrameOfReferenceID;
extern const TimeFrameOfReferenceID systemTimeFrameOfReferenceID;
TimeFrameOfReferenceID getTimeFrameOfReferenceID(const char * name);
bool setSystemTimeFrameOfReferenceName(const char * name);
typedef struct  TimeMark
 TimeMark;
struct  TimeMark
{
    TimeFrameOfReferenceID  frame;

    LinearTimeMark  timemark;

}
;
extern const TimeMark minTimeMark;
extern const TimeMark maxTimeMark;
TimeMark createTimeMark(LinearTimeMark  timemark);
TimeMark createDistributedTimeMark(TimeFrameOfReferenceID  frame, LinearTimeMark  timemark);
void setTimeMarkDependence(TimeMark  former, TimeMark  latter);
typedef enum  CompareResult
{
    EqualCR, LessCR, GreaterCR, NonComparableCR}

 CompareResult;
CompareResult compareTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool equalTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool lessTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool lessOrEqualTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool greaterTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool greaterOrEqualTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool noncomparableTimeMarks(TimeMark  tm1, TimeMark  tm2);
typedef int64_t TimeUnit;
TimeUnit diffTimeMarks(TimeMark  tm1, TimeMark  tm2);
TimeMark addTimeMarks(TimeMark  tm, TimeUnit  delta);
TimeMark subtractTimeMarks(TimeMark  tm, TimeUnit  delta);
typedef struct  TimeInterval
 TimeInterval;
struct  TimeInterval
{
    TimeMark  minMark;

    TimeMark  maxMark;

}
;
extern const TimeInterval overallTimeInterval;
TimeInterval createTimeInterval(TimeMark  minMark, TimeMark  maxMark);
bool areIntersectedTimeIntervals(TimeInterval  ti1, TimeInterval  ti2);
TimeInterval addTimeIntervals(TimeInterval  ti, TimeUnit  delta);
TimeInterval subtractTimeIntervals(TimeInterval  ti, TimeUnit  delta);
int printLinearTimeInterval(char * buffer, TimeInterval  interval);
int printDistributedTimeInterval(char * buffer, TimeInterval  interval);
bool setAutomaticTimeMarksMode(bool  enable);
bool areAutomaticTimeMarksEnabled(void);
TimeMark getCurrentTimeMark(void);
typedef TimeMark (* GetCurrentTimeMarkFuncType)(void);
GetCurrentTimeMarkFuncType setDefaultCurrentTimeMarkFunction(GetCurrentTimeMarkFuncType  new_func);
void setAutomaticTimeMark(TimeMark * timemark);
typedef enum  TSTimeModel
{
    NotUseTSTime, LinearTSTime, DistributedTSTime}

 TSTimeModel;
TSTimeModel setTSTimeModel(TSTimeModel  time_model);
TSTimeModel getTSTimeModel(void);
typedef struct  CallProperties
 CallProperties;
struct  CallProperties
{
    bool  verdict;

    TimeInterval  time;

}
;
typedef long InteractionId;
typedef struct  OracleCallProperties
 OracleCallProperties;
struct  OracleCallProperties
{
    InteractionId  refId;

    bool  verdict;

}
;
void setOracleVerdict(bool  verdict);
bool getOracleVerdict(void);
void clearOracleVerdict(void);
typedef enum  OracleVerdict
{
    OracleVerdict_Ok, OracleVerdict_PreconditionFailed, OracleVerdict_PostconditionFailed}

 OracleVerdict;
typedef struct  CallContextStruct
{
    Object * params;

    TimeInterval  time;

    InteractionId  refId;

}
 CallContextType;
typedef bool (* PreFuncType)(Object * params);
typedef OracleVerdict (* CallPureOracleFuncType)(CallContextType);
typedef void (* TraceModelOperationFuncType)(InteractionId, Object *, ChannelID, TimeInterval);
typedef struct  SpecificationDesc
{
    const char * name;

    const char * subsystem;

    const char * signature;

    PreFuncType  precondition;

    CallPureOracleFuncType  call_pure_oracle;

    TraceModelOperationFuncType  trace_model_operation;

    bool  is_reaction;

    const Type * par_res_type;

}
 SpecificationDesc;
typedef SpecificationDesc* SpecificationID;
typedef Object* (* PtrActionInit)(void);
typedef bool (* PtrActionHasNext)(Object *);
typedef bool (* PtrActionNext)(Object *);
typedef bool (* PtrActionCall)(Object *);
typedef struct 
{
    PtrActionInit  init;

    PtrActionHasNext  has_next;

    PtrActionNext  next;

    PtrActionCall  call;

    const char * name;

}
 ScenarioFunctionDesc;
typedef ScenarioFunctionDesc* ScenarioFunctionID;
void ts_trace_model_operation_timestamp(TimeInterval  timestamp);
void ts_trace_bad_oracle_verdict(void);
void ts_trace_bad_mediator_verdict(void);
Object* * ts_cast_spec_ref_lvalue(const Type * type, Object * * ref);
Object* ts_cast_spec_ref(const Type * type, Object * ref);
Object* ts_check_spec_ref(const Type * type, Object * ref, const char * kind, const char * where);
Object* ts_assign_spec_ref(Object * * left, Object * right, const char * where);
void* ts_destroy_spec_ref(Object * ref);
void _dummy(void * p);
Object* singletonState(void);
void setCheckPrecondition(bool  check);
bool getCheckPrecondition(void);
void setCheckPostcondition(bool  check);
bool getCheckPostcondition(void);
extern const char PRECONDITION_FAILED_MESSAGE[];
extern const char POSTCONDITION_FAILED_MESSAGE[];
extern const char SCENARIO_FUNCTION_FAILED_MESSAGE[];
extern const char INCORRECT_SET_OF_INTERACTIONS_MESSAGE[];
extern const char MEDIATOR_FAILED_MESSAGE[];
extern const char UNCONNECTED_GRAPH_MESSAGE[];
extern const char NONDETERMINISTIC_GRAPH_MESSAGE[];
extern const char SCENARIO_INITIALIZATION_FAILED_MESSAGE[];
extern const char SERIALIZATION_FAILED_MESSAGE[];
extern const char NONSTATIONARY_STATE_MESSAGE[];
void registerReaction(ChannelID  chid, const char * name, SpecificationID  reactionID, Object * data);
void registerReactionWithTimeMark(ChannelID  chid, const char * name, SpecificationID  reactionID, Object * data, TimeMark  mark);
void registerReactionWithTimeInterval(ChannelID  chid, const char * name, SpecificationID  reactionID, Object * data, TimeInterval  interval);
void registerWrongReaction(const char * info);
typedef bool (* ReactionCatcherFuncType)(void *);
void registerReactionCatcher(ReactionCatcherFuncType  catcher, void * par);
bool unregisterReactionCatcher(ReactionCatcherFuncType  catcher, void * par);
bool unregisterReactionCatchers(ReactionCatcherFuncType  catcher);
ChannelID setStimulusChannel(ChannelID  chid);
ChannelID getStimulusChannel(void);
void registerStimulus(const char * name, SpecificationID  stimulusID, Object * data, TimeInterval  interval);
void registerStimulusWithTimeInterval(ChannelID  chid, const char * name, SpecificationID  stimulusID, TimeInterval  interval, ...);
typedef __clock_t clock_t;
typedef __time_t time_t;
struct  tm
{
    int  tm_sec;

    int  tm_min;

    int  tm_hour;

    int  tm_mday;

    int  tm_mon;

    int  tm_year;

    int  tm_wday;

    int  tm_yday;

    int  tm_isdst;

    long int  __tm_gmtoff;

    const char * __tm_zone;

}
;
extern clock_t clock(void) __attribute__(( __nothrow__, __leaf__));
extern time_t time(time_t * __timer) __attribute__(( __nothrow__, __leaf__));
extern double difftime(time_t  __time1, time_t  __time0) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern time_t mktime(struct  tm
 * __tp) __attribute__(( __nothrow__, __leaf__));
extern size_t strftime(char *__restrict__ __s, size_t  __maxsize, const char *__restrict__ __format, const struct  tm
 *__restrict__ __tp) __attribute__(( __nothrow__, __leaf__));
extern struct  tm
* gmtime(const time_t * __timer) __attribute__(( __nothrow__, __leaf__));
extern struct  tm
* localtime(const time_t * __timer) __attribute__(( __nothrow__, __leaf__));
extern char* asctime(const struct  tm
 * __tp) __attribute__(( __nothrow__, __leaf__));
extern char* ctime(const time_t * __timer) __attribute__(( __nothrow__, __leaf__));
extern char* __tzname[2];
extern int __daylight;
extern long int __timezone;
typedef enum 
{
    TD_ok, TD_bad_parameters, TD_not_enough_resources, TD_bad_verdict, TD_faulted, ORACLE_bad_verdict}

 TestVerdict;
extern TestVerdict testVerdict;
typedef enum 
{
    UNTIL_ERROR, UNTIL_END}

 FinishMode;
FinishMode setFinishMode(FinishMode  finish_mode);
FinishMode getFinishMode(void);
int setNumberOfErrorsToFinish(int  error_number);
typedef enum  TSMode
{
    SequentialTSMode, ParallelTSMode}

 TSMode;
TSMode getTSMode(void);
bool setDeferredReactionsMode(bool  enable);
bool areDeferredReactionsEnabled(void);
time_t setWTime(time_t  secs);
time_t setWTimeMSec(time_t  millisecs);
time_t getWTime(void);
time_t getWTimeMSec(void);
bool setFindFirstSeriesOnly(bool  new_value);
bool isFindFirstSeriesOnly(void);
int setFindFirstSeriesOnlyBound(int  bound);
int getFindFirstSeriesOnlyBound(void);
void ts_assert_function(const char * format, va_list  arg_list);
bool startTestSystem(int  argc, char * * argv);
void stopTestSystem(void);
const char* getCurrentTestScenarioName(void);
typedef bool (* PtrIsStationaryState)(void);
typedef Object* (* PtrSaveModelState)(void);
typedef void (* PtrRestoreModelState)(Object *);
typedef void (* PtrObserveState)(void);
typedef void (* PtrDoneEvent)(void);
typedef struct  ModelStateManager
{
    PtrSaveModelState  saveModelState;

    PtrRestoreModelState  restoreModelState;

    PtrIsStationaryState  isStationaryState;

    PtrObserveState  observeState;

}
 ModelStateManager;
typedef bool (* TS_Init)(int, char * *);
typedef void (* TS_Finish)(void);
typedef Object* (* TS_GetState)(void);
typedef String* (* TS_GetStateId)(Object *);
typedef bool (* TS_IsStationaryState)(void);
typedef Object* (* TS_SaveModelState)(void);
typedef void (* TS_RestoreModelState)(Object *);
typedef void (* TS_ObserveState)(void);
typedef struct  TestScenario
{
    const char * name;

    TS_Init  init;

    TS_GetState  getState;

    TS_GetStateId  getStateId;

    TS_SaveModelState  saveModelState;

    TS_RestoreModelState  restoreModelState;

    TS_IsStationaryState  isStationaryState;

    TS_ObserveState  observeState;

    TS_Finish  finish;

    ScenarioFunctionID * actions;

}
 TestScenario;
String* getStateId_Default(Object * obj);
typedef bool (* PtrInit)(int, char * *);
typedef void (* PtrFinish)(void);
typedef Object* (* PtrGetState)(void);
typedef String* (* PtrGetStateId)(Object *);
typedef TestScenario dfsm;
bool start_dfsm(int  argc, char * * argv, dfsm * td);
typedef TestScenario ndfsm;
bool start_ndfsm(int  argc, char * * argv, ndfsm * test);
 typedef void Unit;

extern const Type type_Unit;


Unit* create_Unit();
typedef int c_bool;
void setTraceUserEnv(const char * name, const char * value);
void setTraceEncoding(const char * encoding);
void setTraceDataFormatXML();
void setTraceDataFormatString();
c_bool addTraceToConsole(void);
c_bool removeTraceToConsole(void);
c_bool addTraceToFile(const char * name);
c_bool removeTraceToFile(const char * name);
c_bool isTraceEnabled(void);
c_bool setTraceAccidental(c_bool  enable);
void startTrace(void);
void endTrace(void);
void traceScenarioStart(const char * name);
void traceScenarioParameters(int  argc, const char * * argv);
void traceTestEngineProperty(const char * name, const char * value);
void traceScenarioEnd(void);
void traceScenarioValue(const char * kind, const char * type, const char * name, const char * value);
void traceState(const char * id);
void traceTransitionStart(const char * id);
void traceTransitionEnd(void);
void traceModelOperationStart(const char * kind, const char * subsystem, const char * signature);
void traceModelOperationArgument(const char * type, const char * name, const char * value);
void traceModelOperationResult(const char * type, const char * value);
void traceModelOperationIdentifier(long  id);
void traceModelOperationChannel(long  chid);
void traceModelOperationTimestamp(const char * timestamp);
void traceOracleStart(const char * subsystem, const char * signature, long  refId);
void tracePreconditionEnd(void);
void traceOracleEnd(void);
void traceModelOperationEnd(void);
void traceSeriesStart(void);
void traceSeriesEnd(void);
void tracePrimeFormula(int  id, c_bool  value);
void traceCoverageElement(const char * structureId, const char * coverageId, int  branchId);
void traceMark(const char * mark);
void traceCoverageStructureStart(const char * name);
void traceFormulaeStart(void);
void traceFormula(int  id, const char * text);
void traceFormulaeEnd(void);
void traceCoverageStart(const char * id);
void traceElement(int  id, const char * name);
void traceCoverageEnd(void);
void traceCoverageStructureEnd(void);
void traceException(const char * kind);
void traceInterimException(const char * kind);
void traceExceptionValue(const char * name, const char * value);
void traceExceptionInfo(const char * info);
void traceInternalError(const char * info);
void traceSystemInfo(const char * info);
void traceUserInfo(const char * info);
void traceFormattedUserInfo(const char * format, ...);
c_bool isInTrace(void);
c_bool isInScenario(void);
c_bool isInTransition(void);
c_bool isInSeries(void);
c_bool isInModelOperation(void);
c_bool isInOracle(void);
c_bool isInPrecondition(void);
c_bool isInCoverageStructure(void);
c_bool isInFormulae(void);
c_bool isInCoverage(void);
int getTraceId(void);
void flushTrace(void);
void closeTrace(void);
typedef const char* CoverageText;
typedef int CoverageElement;
typedef enum 
{
    PRIMARY_COVERAGE, DOMAIN_VARIATION_COVERAGE, MULTIPLICATION_COVERAGE}

 COVERAGE_KIND;
typedef struct  _CoverageDesc
{
    COVERAGE_KIND  kind;

    int  size;

    int  base_num;

    int  order;

    bool  is_global;

    int  last_trace_id;

    CoverageText  name;

    CoverageElement  (* calc)();

    bool  (* filter)(CoverageElement);

    const void * data[];

}
 CoverageDesc;
extern int _CE_OUT_OF_COVERAGE;
const CoverageDesc* cov_component(const CoverageDesc * cov_desc, int  a);
CoverageElement ce_product(const CoverageDesc * cov_desc, ...);
CoverageElement ce_coord(const CoverageDesc * cov_desc, CoverageElement  element, int  axis, CoverageDesc * * p_prim_cov_desc);
CoverageText ce_txt(const CoverageDesc * cov_desc, CoverageElement  elem);
bool isElementInCoverage(const CoverageDesc * cov_desc, int  element);
void traceReachedCoverageElement(CoverageDesc * cov_desc, int  element);
void traceCoverageStructure(CoverageDesc * cov_desc);
const char* ts_get_ctesk_version(void);
const char* ts_get_ctesk_build(void);
void setBadVerdict(const char * msg);
bool isBadVerdict(void);
void clearBadVerdict(void);
enum  TS_Verdict
{
    TS_VERDICT_PRE = 1, TS_VERDICT_POST = 2, TS_VERDICT_MEDIATOR = 4, TS_VERDICT_SCENARIO = 8, TS_VERDICT_ALL = 15}

;
typedef void (* VerdictEventHandler)(bool  verdict);
void ts_set_verdict_event_handler(enum  TS_Verdict  ts_verdict_flags, VerdictEventHandler  handler);
void ts_fire_verdict_event(enum  TS_Verdict  ts_verdict_flag, bool  verdict);
 typedef struct  List
 List;

extern const Type type_List;


 typedef struct  Set
 Set;

extern const Type type_Set;


Set* create_Set(const Type * elem_type);
Set* createCustomized_Set(const Type * elem_type, int  initialCapacity);
int size_Set(Set * self);
bool isEmpty_Set(Set * self);
bool contains_Set(Set * self, Object * ref);
bool add_Set(Set * self, Object * ref);
bool remove_Set(Set * self, Object * ref);
bool containsAll_Set(Set * self, Set * set);
bool addAll_Set(Set * self, Set * set);
bool retainAll_Set(Set * self, Set * set);
bool removeAll_Set(Set * self, Set * set);
void clear_Set(Set * self);
Object* get_Set(Set * self, int  index);
List* toList_Set(Set * self);
Type* elemType_Set(Set * self);
List* create_List(const Type * elem_type);
List* createCustomized_List(const Type * elem_type, int  initialCapacity);
void add_List(List * self, int  index, Object * ref);
void append_List(List * self, Object * ref);
void clear_List(List * self);
bool contains_List(List * self, Object * ref);
Object* get_List(List * self, int  index);
int indexOf_List(List * self, Object * ref);
bool isEmpty_List(List * self);
int lastIndexOf_List(List * self, Object * ref);
void remove_List(List * self, int  index);
void set_List(List * self, int  index, Object * ref);
int size_List(List * self);
List* subList_List(List * self, int  fromIndex, int  toIndex);
void addAll_List(List * self, int  index, List * other);
void appendAll_List(List * self, List * other);
Set* toSet_List(List * self);
Type* elemType_List(List * self);
extern  List* stck;
bool invariant_var_stck(void);
#ifndef PAR_RES_TYPE_push_spec_DEFINED
#define PAR_RES_TYPE_push_spec_DEFINED

struct PAR_RES_TYPE_push_spec
{
int inpar1;
int outpar1;
bool res;
};

typedef struct PAR_RES_TYPE_push_spec PAR_RES_TYPE_push_spec;
extern const Type type_PAR_RES_TYPE_push_spec;

#endif

#ifndef CONTEXT_TYPE_push_spec_DEFINED
#define CONTEXT_TYPE_push_spec_DEFINED

typedef
struct CONTEXT_TYPE_push_spec
{
  PAR_RES_TYPE_push_spec* params;
  TimeInterval  time;
  InteractionId refId;
} CONTEXT_TYPE_push_spec;

#endif

extern CONTEXT_TYPE_push_spec __context_push_spec;

#ifndef MEDIATOR_push_spec_DEFINED
#define MEDIATOR_push_spec_DEFINED
  typedef bool (*MEDIATOR_FUNC_push_spec)( CallProperties*, int i );
  typedef struct MEDIATOR_push_spec
   {
    MEDIATOR_FUNC_push_spec sequential_mediator;
    MEDIATOR_FUNC_push_spec call_mediator;
    MEDIATOR_FUNC_push_spec parallel_mediator;
   } 
  MEDIATOR_push_spec;
#endif

MEDIATOR_push_spec set_mediator_push_spec( MEDIATOR_push_spec m );

bool pre_push_spec( int i );

bool oracle_push_spec( MEDIATOR_FUNC_push_spec __media, OracleCallProperties* __oracle_properties, int i );

OracleVerdict call_pure_oracle_push_spec( CONTEXT_TYPE_push_spec context );

bool call_active_oracle_push_spec( int i );

extern SpecificationID push_spec;

#ifndef PAR_RES_TYPE_pop_spec_DEFINED
#define PAR_RES_TYPE_pop_spec_DEFINED

struct PAR_RES_TYPE_pop_spec
{
int *inpar1;
int *outpar1;
bool res;
};

typedef struct PAR_RES_TYPE_pop_spec PAR_RES_TYPE_pop_spec;
extern const Type type_PAR_RES_TYPE_pop_spec;

#endif

#ifndef CONTEXT_TYPE_pop_spec_DEFINED
#define CONTEXT_TYPE_pop_spec_DEFINED

typedef
struct CONTEXT_TYPE_pop_spec
{
  PAR_RES_TYPE_pop_spec* params;
  TimeInterval  time;
  InteractionId refId;
} CONTEXT_TYPE_pop_spec;

#endif

extern CONTEXT_TYPE_pop_spec __context_pop_spec;

#ifndef MEDIATOR_pop_spec_DEFINED
#define MEDIATOR_pop_spec_DEFINED
  typedef bool (*MEDIATOR_FUNC_pop_spec)( CallProperties*, int *item );
  typedef struct MEDIATOR_pop_spec
   {
    MEDIATOR_FUNC_pop_spec sequential_mediator;
    MEDIATOR_FUNC_pop_spec call_mediator;
    MEDIATOR_FUNC_pop_spec parallel_mediator;
   } 
  MEDIATOR_pop_spec;
#endif

MEDIATOR_pop_spec set_mediator_pop_spec( MEDIATOR_pop_spec m );

bool pre_pop_spec( int *item );

bool oracle_pop_spec( MEDIATOR_FUNC_pop_spec __media, OracleCallProperties* __oracle_properties, int *item );

OracleVerdict call_pure_oracle_pop_spec( CONTEXT_TYPE_pop_spec context );

bool call_active_oracle_pop_spec( int *item );

extern SpecificationID pop_spec;

 typedef signed int Integer;

extern const Type type_Integer;


 typedef unsigned int UInteger;

extern const Type type_UInteger;


Integer* create_Integer(int  i);
UInteger* create_UInteger(unsigned int  i);
int value_Integer(Integer * i);
unsigned int value_UInteger(UInteger * i);
 List* stck;
bool invariant_var_stck(void);
static SpecTypeDesc __type_desc__ref_List;
bool invariant_var_stck(void)
{
    if (!ts_check_invariant_sectype( (SECTypeDesc*)&__type_desc__ref_List, &stck ))
      return 0;
    {
        bool __res = 0;
        int __up = 0, __cmd = -3;
        _dummy( &__up ); _dummy( &__cmd );
        {
            { __res = (size_List(r(stck)) <= 10); goto __destroy_body; }


        }

    goto __destroy_body;
    __destroy_body:;
        return __res;
    }
}

CoverageElement _cov_calc_StackCoverage( List *stack );

CoverageDesc _cov_desc_StackCoverage =
{ PRIMARY_COVERAGE
, 3
, 0
, 1
, 1
, -1
, "StackCoverage"
, &_cov_calc_StackCoverage
, 0
, { "empty stack"
  , "full stack"
  , "nonempty stack"
  }
};

#ifndef _COV_STRUCT_StackCoverage
#define _COV_STRUCT_StackCoverage

struct _cov_struct_StackCoverage
{
    const int empty;
    const int full;
    const int nonempty;
    CoverageDesc* desc;
};

#endif

struct _cov_struct_StackCoverage StackCoverage = 
{ 0
, 1
, 2
, &_cov_desc_StackCoverage
};

CoverageElement _cov_calc_StackCoverage( List *stack )
{
    CoverageElement __res = _CE_OUT_OF_COVERAGE;
    int __up = 0, __cmd = -3;
    _dummy( &__up ); _dummy( &__cmd );
    {
        if( size_List(r(stack)) == 0 )
        {
            { __res = (StackCoverage.empty); goto __destroy_body; }
        }
        else
        {
            if( size_List(r(stack)) == 10 )
            {
                { __res = (StackCoverage.full); goto __destroy_body; }
            }
            else
            {
                { __res = (StackCoverage.nonempty); goto __destroy_body; }
            }
        }


    }
goto __destroy_body;
__destroy_body:;
    destroy( stack );
    return __res;
}

static SimpleTypeDesc __type_desc__int;

static SimpleTypeDesc __type_desc__bool;

extern SpecificationID push_spec;

#ifndef PAR_RES_TYPE_push_spec_DEFINED
#define PAR_RES_TYPE_push_spec_DEFINED

struct PAR_RES_TYPE_push_spec
{
int inpar1;
int outpar1;
bool res;
};

typedef struct PAR_RES_TYPE_push_spec PAR_RES_TYPE_push_spec;
extern const Type type_PAR_RES_TYPE_push_spec;

#endif

static StructTypeDesc __type_desc__struct_PAR_RES_TYPE_push_spec;

static void init_PAR_RES_TYPE_push_spec( struct PAR_RES_TYPE_push_spec *obj, va_list* arg_list )
{
    obj->inpar1 = va_arg( *arg_list, int );
    obj->outpar1 = va_arg( *arg_list, int );
    obj->res = (bool)va_arg( *arg_list, int );
}

static int compare_PAR_RES_TYPE_push_spec( struct PAR_RES_TYPE_push_spec *left, struct PAR_RES_TYPE_push_spec *right )
{
    if( ts_equals_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_push_spec, left, right ) )
      return 0;
    return 1;
}

static String* to_string_PAR_RES_TYPE_push_spec( struct PAR_RES_TYPE_push_spec *obj )
{
    return ts_to_string_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_push_spec, obj );
}

static String* to_XML_PAR_RES_TYPE_push_spec( struct PAR_RES_TYPE_push_spec *obj )
{
    return ts_to_XML_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_push_spec, obj );
}

const Type type_PAR_RES_TYPE_push_spec =
{
  "PAR_RES_TYPE_push_spec",
  sizeof(struct PAR_RES_TYPE_push_spec),
  &type_Object,
  (Init)init_PAR_RES_TYPE_push_spec,
  (Copy)copy_Default,
  (Compare)compare_PAR_RES_TYPE_push_spec,
  (ToString)to_string_PAR_RES_TYPE_push_spec,
  (ToXML)to_XML_PAR_RES_TYPE_push_spec,
  (CheckInvariant)check_invariant_Default,
  (Enumerate)enumerate_Default,
  (Destroy)destroy_Default
};


#ifndef CONTEXT_TYPE_push_spec_DEFINED
#define CONTEXT_TYPE_push_spec_DEFINED

typedef
struct CONTEXT_TYPE_push_spec
{
  PAR_RES_TYPE_push_spec* params;
  TimeInterval  time;
  InteractionId refId;
} CONTEXT_TYPE_push_spec;

#endif

CONTEXT_TYPE_push_spec __context_push_spec;

#ifndef MEDIATOR_push_spec_DEFINED
#define MEDIATOR_push_spec_DEFINED
  typedef bool (*MEDIATOR_FUNC_push_spec)( CallProperties*, int i );
  typedef struct MEDIATOR_push_spec
   {
    MEDIATOR_FUNC_push_spec sequential_mediator;
    MEDIATOR_FUNC_push_spec call_mediator;
    MEDIATOR_FUNC_push_spec parallel_mediator;
   } 
  MEDIATOR_push_spec;
#endif

static MEDIATOR_push_spec __mediator_push_spec;

MEDIATOR_push_spec set_mediator_push_spec( MEDIATOR_push_spec m )
{
  MEDIATOR_push_spec old_m = __mediator_push_spec;
  __mediator_push_spec = m;
  return old_m;
}

bool pre_push_spec( int i )
{
    bool pre = 1;
    if (pre)
    {
        bool __alias1_has_value = 
                 1;
        _dummy( &__alias1_has_value );
        if (pre && __alias1_has_value)
        {
            pre = invariant_var_stck();
        }
    }
    return pre;
}

static bool __pre_push_spec( PAR_RES_TYPE_push_spec* params )
{
    bool res = pre_push_spec(
              params->inpar1
    );
    destroy(params);
    return res;
}

CoverageElement _local_cov_calc_push_spec( unsigned int _cov_num, int i );


CoverageElement _cov_calc_push_spec_c( int i );

CoverageDesc _cov_desc_push_spec_c =
{ DOMAIN_VARIATION_COVERAGE
, 3
, 1
, 1
, 0
, -1
, "c"
, &_cov_calc_push_spec_c
, 0
, { &_cov_desc_StackCoverage
  }
};

#ifndef _COV_STRUCT_push_spec_c
#define _COV_STRUCT_push_spec_c

struct _cov_struct_push_spec_c
{
    CoverageDesc* desc;
};

#endif

struct _cov_struct_push_spec_c push_spec_c = 
{ &_cov_desc_push_spec_c
};

CoverageElement _cov_calc_push_spec_c( int i )
{
    CoverageElement __res = _local_cov_calc_push_spec( 0 ,  i
         );
    return __res;
}

CoverageElement _local_cov_calc_push_spec( unsigned int _cov_num, int i )
{
    bool pre = 1;
    int _cov_values[ 1 ];
    assertion( _cov_num < 1
             , "_local_cov_calc_push_spec: illegal _cov_num"
             );
    if( pre )
    {
        bool __alias1_has_value = 
                 1;
        _dummy( &__alias1_has_value );
        if (pre && __alias1_has_value)
        {
            pre = invariant_var_stck();
        }
        if( pre )
        {
            int __up = 0, __cmd = -3;
            _dummy( &__up ); _dummy( &__cmd );
            {
                // calculation of coverage 'c'
                _cov_values[ 0 /* c */ ] = _CE_OUT_OF_COVERAGE;
                _cov_values[ 0 /* c */ ] = 
                    ce_product( &_cov_desc_push_spec_c
                              , _cov_calc_StackCoverage( r(stck) )
                              );




            }

        }
    }
    if( !pre ) return _CE_OUT_OF_COVERAGE;
    return _cov_values[ _cov_num ];
}

void trace_info_push_spec(void)
{
    traceCoverageStructureStart( "" );
    traceCoverageStructure( push_spec_c.desc );
    traceFormulaeStart();
    traceFormula( 0, "invariant var @stck" );
    traceFormula( 1, "invariant var stck" );
    traceFormulaeEnd();
    traceCoverageStructureEnd();
}

void trace_oracle_start_push_spec(InteractionId refId)
{
    static int last_trace_id = -1;

    traceOracleStart( push_spec->subsystem, push_spec->signature, refId );

    if( last_trace_id < getTraceId() )
    {
        last_trace_id = getTraceId();
        trace_info_push_spec();
    }
}

bool oracle_push_spec( MEDIATOR_FUNC_push_spec __media, OracleCallProperties* __oracle_properties, int i )
{
    bool pre = 1;
    CoverageElement _cov_val_push_spec_c = _CE_OUT_OF_COVERAGE;
    CallProperties __properties;
    bool __res;

    assertion( __media != (void*)0,  "Mediator of push_spec is not set up");
    assertion( __oracle_properties != (void*)0, "Oracle properties cannot be NULL");

    __oracle_properties->verdict = 1;
    trace_oracle_start_push_spec( __oracle_properties->refId );

    assertion(pre, PRECONDITION_FAILED_MESSAGE);
    {
        bool __alias1_has_value = 
                 1;
        bool __pre_expr_0_has_value = 0;
        List *__pre_expr_0;
        bool __pre_expr_1_has_value = 0;
        List *__pre_expr_1;
        bool __pre_expr_2_has_value = 0;
        List *__pre_expr_2;
        _dummy( &__alias1_has_value );
        if (pre && __alias1_has_value)
        {
            pre = invariant_var_stck();
            tracePrimeFormula( 0, pre );
            if (!pre) traceSystemInfo( "Invariant of stck failed" );
        }
        assertion(pre, PRECONDITION_FAILED_MESSAGE);
        {
            int __up = 0, __cmd = -3;
            _dummy( &__up ); _dummy( &__cmd );
            {
                tracePreconditionEnd();
                // calculation of coverage 'c'
                _cov_val_push_spec_c = 
                    ce_product( &_cov_desc_push_spec_c
                              , _cov_calc_StackCoverage( r(stck) )
                              );

                traceReachedCoverageElement( push_spec_c.desc, _cov_val_push_spec_c );

                __pre_expr_0_has_value = 
                         1;
                __pre_expr_1_has_value = 
                         1;
                __pre_expr_2_has_value = 
                         1;
                ts_start_copy_sectype();
                if (__pre_expr_0_has_value)
                {
                    List *__tmp_var = stck;
                    ts_copy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                                   , &__pre_expr_0
                                   , &__tmp_var
                                   , 0
                                   );
                }
                if (__pre_expr_1_has_value)
                {
                    List *__tmp_var = stck;
                    ts_copy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                                   , &__pre_expr_1
                                   , &__tmp_var
                                   , 0
                                   );
                }
                if (__pre_expr_2_has_value)
                {
                    List *__tmp_var = stck;
                    ts_copy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                                   , &__pre_expr_2
                                   , &__tmp_var
                                   , 0
                                   );
                }
                ts_finish_copy_sectype();
                __res = __media( &__properties
                         ,  i
                       );
                __oracle_properties->verdict = __properties.verdict;
                if( getCheckPostcondition() && __oracle_properties->verdict )
                {
                    {
                        if( size_List(r((assertion( __pre_expr_0_has_value, "Incorrect value of '@stck'" ), __pre_expr_0))) == 10 )
                        {
                            {
                               __oracle_properties->verdict = ((compare(r((assertion( __pre_expr_1_has_value, "Incorrect value of '@stck'" ), __pre_expr_1))
                            , r(stck)) == 0) && !__res);
                               goto __after_post;
                            }
                        }
                        else
                        {
                            {
                               __oracle_properties->verdict = (((compare(r((assertion( __pre_expr_2_has_value, "Incorrect value of '@stck'" ), __pre_expr_2))
                            , subList_List(r(stck)
                            , 1
                            , size_List(r(stck)))) == 0) && i == value_Integer(ts_check_spec_ref( &type_Integer, get_List(r(stck)
                            , 0), "1 argument of value_Integer", "stack_model.sec(58,37)" )) && __res));
                               goto __after_post;
                            }
                        }


                    }
                __after_post:
                    if (!__oracle_properties->verdict)
                      ts_trace_bad_oracle_verdict();
                }


            }

        }
        ts_start_destroy_sectype();
        if( __pre_expr_0_has_value )
        {
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                              , &__pre_expr_0
                              , 0
                              );
        }
        if( __pre_expr_1_has_value )
        {
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                              , &__pre_expr_1
                              , 0
                              );
        }
        if( __pre_expr_2_has_value )
        {
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                              , &__pre_expr_2
                              , 0
                              );
        }
        ts_finish_destroy_sectype();
    }
    traceOracleEnd();
    return __res;
}

OracleVerdict call_pure_oracle_push_spec( CONTEXT_TYPE_push_spec context )
{
    OracleCallProperties __oracle_properties;
    bool __res;
    if ( getCheckPrecondition() && !pre_push_spec(
              context.params->inpar1
                     )
       )
    {
        destroy(context.params);
        trace_oracle_start_push_spec( context.refId );
        traceException( PRECONDITION_FAILED_MESSAGE );
        traceOracleEnd();
        return OracleVerdict_PreconditionFailed;
    }
    __context_push_spec = context;
    __oracle_properties.refId = __context_push_spec.refId;

    __res = oracle_push_spec(
              __mediator_push_spec.parallel_mediator
             ,&__oracle_properties
             ,  context.params->inpar1
                   );
    destroy( __context_push_spec.params );
    __context_push_spec.params = (void*)0;
    return __oracle_properties.verdict ? OracleVerdict_Ok : OracleVerdict_PostconditionFailed;
}

bool call_active_oracle_push_spec( int i )
{
    CallProperties __properties;
    bool __res;
    String* tmp_;
    assertion( __mediator_push_spec.sequential_mediator != (void*)0, "Mediator of push_spec is not set up" );
    traceModelOperationStart( "stimulus", push_spec->subsystem, push_spec->signature );
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__int
                              , &i
                              );
    traceModelOperationArgument( "int"
                               , "i"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);

    switch (getTSMode())
    {
        case SequentialTSMode:
            {
                OracleCallProperties __oracle_properties;
                __oracle_properties.refId = -1;
                __res = oracle_push_spec(
                           __mediator_push_spec.sequential_mediator
                          ,&__oracle_properties
                         ,  i
                               );
                setOracleVerdict( __oracle_properties.verdict );
                break;
            }
        case ParallelTSMode:
        {
            PAR_RES_TYPE_push_spec* __context;
            int inpar1;

            ts_copy_sectype( (SECTypeDesc*)&__type_desc__int
                           , &inpar1
                           , &i
                           , 0
                           );

            __res = __mediator_push_spec.call_mediator(
                      &__properties
                     ,  i
                                             );
            __context = create( &type_PAR_RES_TYPE_push_spec
                     ,  inpar1
                     ,  i
                 , __res
                 );
            registerStimulus( "push_spec", push_spec, __context, __properties.time );

            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__int
                              , &inpar1
                              , 0
                              );

            setOracleVerdict( __properties.verdict );
            break;
        }
        default:
          assertion( 0, "Unexpected mode of the test system" );
    }
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__bool, &__res );
    traceModelOperationResult( "bool"
                             , toCharArray_String(r(tmp_))
                             );
    destroy(tmp_);
    if( getTSMode() == ParallelTSMode )
    {
        traceModelOperationChannel(getStimulusChannel());
        ts_trace_model_operation_timestamp(__properties.time);
    }
    traceModelOperationEnd();
    return __res;
}

void trace_model_operation_push_spec( InteractionId refId, PAR_RES_TYPE_push_spec* params, ChannelID chid, TimeInterval timestamp )
{
    String* tmp_;
    traceModelOperationStart( "stimulus", push_spec->subsystem, push_spec->signature );
    traceModelOperationIdentifier(refId);
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__int, &params->inpar1 );
    traceModelOperationArgument( "int"
                               , "i"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);

    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__bool, &params->res );
    traceModelOperationResult( "bool"
                             , toCharArray_String(r(tmp_))
                             );
    destroy(tmp_);
    traceModelOperationChannel(chid);
    ts_trace_model_operation_timestamp(timestamp);
    traceModelOperationEnd();
    destroy(params);
}

SpecificationDesc desc_push_spec =
{
    "push_spec",
    "",
    "bool push_spec( int i )",
    (PreFuncType)__pre_push_spec,
    (CallPureOracleFuncType)call_pure_oracle_push_spec,
    (TraceModelOperationFuncType)trace_model_operation_push_spec,
    0,
    &type_PAR_RES_TYPE_push_spec
};

SpecificationID push_spec = &desc_push_spec;

static PointerTypeDesc __type_desc__ptr_to__int;

extern SpecificationID pop_spec;

#ifndef PAR_RES_TYPE_pop_spec_DEFINED
#define PAR_RES_TYPE_pop_spec_DEFINED

struct PAR_RES_TYPE_pop_spec
{
int *inpar1;
int *outpar1;
bool res;
};

typedef struct PAR_RES_TYPE_pop_spec PAR_RES_TYPE_pop_spec;
extern const Type type_PAR_RES_TYPE_pop_spec;

#endif

static StructTypeDesc __type_desc__struct_PAR_RES_TYPE_pop_spec;

static void init_PAR_RES_TYPE_pop_spec( struct PAR_RES_TYPE_pop_spec *obj, va_list* arg_list )
{
    {
        int *__tmp;
        __tmp = va_arg( *arg_list, int * );
        ts_copy_sectype( (SECTypeDesc*)&__type_desc__ptr_to__int
                       , &obj->inpar1
                       , &__tmp
                       , 1
                       );
    }
    {
        int *__tmp;
        __tmp = va_arg( *arg_list, int * );
        ts_copy_sectype( (SECTypeDesc*)&__type_desc__ptr_to__int
                       , &obj->outpar1
                       , &__tmp
                       , 1
                       );
    }
    obj->res = (bool)va_arg( *arg_list, int );
}

static void copy_PAR_RES_TYPE_pop_spec( struct PAR_RES_TYPE_pop_spec *src, struct PAR_RES_TYPE_pop_spec *dst )
{
    ts_copy_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_pop_spec
                   , dst
                   , src
                   , 1
                   );
}

static int compare_PAR_RES_TYPE_pop_spec( struct PAR_RES_TYPE_pop_spec *left, struct PAR_RES_TYPE_pop_spec *right )
{
    if( ts_equals_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_pop_spec, left, right ) )
      return 0;
    return 1;
}

static String* to_string_PAR_RES_TYPE_pop_spec( struct PAR_RES_TYPE_pop_spec *obj )
{
    return ts_to_string_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_pop_spec, obj );
}

static String* to_XML_PAR_RES_TYPE_pop_spec( struct PAR_RES_TYPE_pop_spec *obj )
{
    return ts_to_XML_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_pop_spec, obj );
}

static void destroy_PAR_RES_TYPE_pop_spec( struct PAR_RES_TYPE_pop_spec *obj )
{
    ts_destroy_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_pop_spec, obj, 1 );
}

const Type type_PAR_RES_TYPE_pop_spec =
{
  "PAR_RES_TYPE_pop_spec",
  sizeof(struct PAR_RES_TYPE_pop_spec),
  &type_Object,
  (Init)init_PAR_RES_TYPE_pop_spec,
  (Copy)copy_PAR_RES_TYPE_pop_spec,
  (Compare)compare_PAR_RES_TYPE_pop_spec,
  (ToString)to_string_PAR_RES_TYPE_pop_spec,
  (ToXML)to_XML_PAR_RES_TYPE_pop_spec,
  (CheckInvariant)check_invariant_Default,
  (Enumerate)enumerate_Default,
  (Destroy)destroy_PAR_RES_TYPE_pop_spec
};


#ifndef CONTEXT_TYPE_pop_spec_DEFINED
#define CONTEXT_TYPE_pop_spec_DEFINED

typedef
struct CONTEXT_TYPE_pop_spec
{
  PAR_RES_TYPE_pop_spec* params;
  TimeInterval  time;
  InteractionId refId;
} CONTEXT_TYPE_pop_spec;

#endif

CONTEXT_TYPE_pop_spec __context_pop_spec;

#ifndef MEDIATOR_pop_spec_DEFINED
#define MEDIATOR_pop_spec_DEFINED
  typedef bool (*MEDIATOR_FUNC_pop_spec)( CallProperties*, int *item );
  typedef struct MEDIATOR_pop_spec
   {
    MEDIATOR_FUNC_pop_spec sequential_mediator;
    MEDIATOR_FUNC_pop_spec call_mediator;
    MEDIATOR_FUNC_pop_spec parallel_mediator;
   } 
  MEDIATOR_pop_spec;
#endif

static MEDIATOR_pop_spec __mediator_pop_spec;

MEDIATOR_pop_spec set_mediator_pop_spec( MEDIATOR_pop_spec m )
{
  MEDIATOR_pop_spec old_m = __mediator_pop_spec;
  __mediator_pop_spec = m;
  return old_m;
}

bool pre_pop_spec( int *item )
{
    bool pre = 1;
    if (pre)
    {
        bool __alias1_has_value = 
                 1;
        bool i_has_value = 
                 1;
        _dummy( &__alias1_has_value );
        _dummy( &i_has_value );
        if (pre && __alias1_has_value)
        {
            pre = invariant_var_stck();
        }
    }
    return pre;
}

static bool __pre_pop_spec( PAR_RES_TYPE_pop_spec* params )
{
    bool res = pre_pop_spec(
              params->inpar1
    );
    destroy(params);
    return res;
}

CoverageElement _local_cov_calc_pop_spec( unsigned int _cov_num, int *item );


CoverageElement _cov_calc_pop_spec_c( int *item );

CoverageDesc _cov_desc_pop_spec_c =
{ DOMAIN_VARIATION_COVERAGE
, 3
, 1
, 1
, 0
, -1
, "c"
, &_cov_calc_pop_spec_c
, 0
, { &_cov_desc_StackCoverage
  }
};

#ifndef _COV_STRUCT_pop_spec_c
#define _COV_STRUCT_pop_spec_c

struct _cov_struct_pop_spec_c
{
    CoverageDesc* desc;
};

#endif

struct _cov_struct_pop_spec_c pop_spec_c = 
{ &_cov_desc_pop_spec_c
};

CoverageElement _cov_calc_pop_spec_c( int *item )
{
    CoverageElement __res = _local_cov_calc_pop_spec( 0 ,  item
         );
    return __res;
}

CoverageElement _local_cov_calc_pop_spec( unsigned int _cov_num, int *item )
{
    bool pre = 1;
    int _cov_values[ 1 ];
    assertion( _cov_num < 1
             , "_local_cov_calc_pop_spec: illegal _cov_num"
             );
    if( pre )
    {
        bool __alias1_has_value = 
                 1;
        bool i_has_value = 
                 1;
        _dummy( &__alias1_has_value );
        _dummy( &i_has_value );
        if (pre && __alias1_has_value)
        {
            pre = invariant_var_stck();
        }
        if( pre )
        {
            int __up = 0, __cmd = -3;
            _dummy( &__up ); _dummy( &__cmd );
            {
                // calculation of coverage 'c'
                _cov_values[ 0 /* c */ ] = _CE_OUT_OF_COVERAGE;
                _cov_values[ 0 /* c */ ] = 
                    ce_product( &_cov_desc_pop_spec_c
                              , _cov_calc_StackCoverage( r(stck) )
                              );




            }

        }
    }
    if( !pre ) return _CE_OUT_OF_COVERAGE;
    return _cov_values[ _cov_num ];
}

void trace_info_pop_spec(void)
{
    traceCoverageStructureStart( "" );
    traceCoverageStructure( pop_spec_c.desc );
    traceFormulaeStart();
    traceFormula( 0, "invariant var @stck" );
    traceFormula( 1, "invariant var stck" );
    traceFormulaeEnd();
    traceCoverageStructureEnd();
}

void trace_oracle_start_pop_spec(InteractionId refId)
{
    static int last_trace_id = -1;

    traceOracleStart( pop_spec->subsystem, pop_spec->signature, refId );

    if( last_trace_id < getTraceId() )
    {
        last_trace_id = getTraceId();
        trace_info_pop_spec();
    }
}

bool oracle_pop_spec( MEDIATOR_FUNC_pop_spec __media, OracleCallProperties* __oracle_properties, int *item )
{
    bool pre = 1;
    CoverageElement _cov_val_pop_spec_c = _CE_OUT_OF_COVERAGE;
    CallProperties __properties;
    bool __res;

    assertion( __media != (void*)0,  "Mediator of pop_spec is not set up");
    assertion( __oracle_properties != (void*)0, "Oracle properties cannot be NULL");

    __oracle_properties->verdict = 1;
    trace_oracle_start_pop_spec( __oracle_properties->refId );

    assertion(pre, PRECONDITION_FAILED_MESSAGE);
    {
        bool __alias1_has_value = 
                 1;
        bool i_has_value = 
                 1;
        bool __pre_expr_0_has_value = 0;
        List *__pre_expr_0;
        bool __pre_expr_1_has_value = 0;
        List *__pre_expr_1;
        bool __pre_expr_2_has_value = 0;
        List *__pre_expr_2;
        bool __pre_expr_3_has_value = 0;
        List *__pre_expr_3;
        bool __pre_expr_4_has_value = 0;
        List *__pre_expr_4;
        _dummy( &__alias1_has_value );
        _dummy( &i_has_value );
        if (pre && __alias1_has_value)
        {
            pre = invariant_var_stck();
            tracePrimeFormula( 0, pre );
            if (!pre) traceSystemInfo( "Invariant of stck failed" );
        }
        assertion(pre, PRECONDITION_FAILED_MESSAGE);
        {
            int __up = 0, __cmd = -3;
            _dummy( &__up ); _dummy( &__cmd );
            {
                tracePreconditionEnd();
                // calculation of coverage 'c'
                _cov_val_pop_spec_c = 
                    ce_product( &_cov_desc_pop_spec_c
                              , _cov_calc_StackCoverage( r(stck) )
                              );

                traceReachedCoverageElement( pop_spec_c.desc, _cov_val_pop_spec_c );

                __pre_expr_0_has_value = 
                         1;
                __pre_expr_1_has_value = 
                         1;
                __pre_expr_2_has_value = 
                         1;
                __pre_expr_3_has_value = 
                         1;
                __pre_expr_4_has_value = 
                         1;
                ts_start_copy_sectype();
                if (__pre_expr_0_has_value)
                {
                    List *__tmp_var = stck;
                    ts_copy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                                   , &__pre_expr_0
                                   , &__tmp_var
                                   , 0
                                   );
                }
                if (__pre_expr_1_has_value)
                {
                    List *__tmp_var = stck;
                    ts_copy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                                   , &__pre_expr_1
                                   , &__tmp_var
                                   , 0
                                   );
                }
                if (__pre_expr_2_has_value)
                {
                    List *__tmp_var = stck;
                    ts_copy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                                   , &__pre_expr_2
                                   , &__tmp_var
                                   , 0
                                   );
                }
                if (__pre_expr_3_has_value)
                {
                    List *__tmp_var = stck;
                    ts_copy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                                   , &__pre_expr_3
                                   , &__tmp_var
                                   , 0
                                   );
                }
                if (__pre_expr_4_has_value)
                {
                    List *__tmp_var = stck;
                    ts_copy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                                   , &__pre_expr_4
                                   , &__tmp_var
                                   , 0
                                   );
                }
                ts_finish_copy_sectype();
                __res = __media( &__properties
                         ,  item
                       );
                __oracle_properties->verdict = __properties.verdict;
                if( getCheckPostcondition() && __oracle_properties->verdict )
                {
                    {
                        if( size_List(r((assertion( __pre_expr_0_has_value, "Incorrect value of '@stck'" ), __pre_expr_0))) == 0 )
                        {
                            {
                               __oracle_properties->verdict = ((compare(r((assertion( __pre_expr_1_has_value, "Incorrect value of '@stck'" ), __pre_expr_1))
                            , r(stck)) == 0) && !__res);
                               goto __after_post;
                            }
                        }
                        else
                        {
                            {
                               __oracle_properties->verdict = (((compare(r(stck)
                            , subList_List(r((assertion( __pre_expr_2_has_value, "Incorrect value of '@stck'" ), __pre_expr_2))
                            , 1
                            , size_List(r((assertion( __pre_expr_3_has_value, "Incorrect value of '@stck'" ), __pre_expr_3))))) == 0) && (*( assertion( i_has_value && (item != (void*)0), "i is not accessible" ), &*item ) ) == value_Integer(ts_check_spec_ref( &type_Integer, get_List(r((assertion( __pre_expr_4_has_value, "Incorrect value of '@stck'" ), __pre_expr_4))
                            , 0), "1 argument of value_Integer", "stack_model.sec(85,38)" )) && __res));
                               goto __after_post;
                            }
                        }


                    }
                __after_post:
                    if (!__oracle_properties->verdict)
                      ts_trace_bad_oracle_verdict();
                }


            }

        }
        ts_start_destroy_sectype();
        if( __pre_expr_0_has_value )
        {
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                              , &__pre_expr_0
                              , 0
                              );
        }
        if( __pre_expr_1_has_value )
        {
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                              , &__pre_expr_1
                              , 0
                              );
        }
        if( __pre_expr_2_has_value )
        {
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                              , &__pre_expr_2
                              , 0
                              );
        }
        if( __pre_expr_3_has_value )
        {
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                              , &__pre_expr_3
                              , 0
                              );
        }
        if( __pre_expr_4_has_value )
        {
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__ref_List
                              , &__pre_expr_4
                              , 0
                              );
        }
        ts_finish_destroy_sectype();
    }
    traceOracleEnd();
    return __res;
}

OracleVerdict call_pure_oracle_pop_spec( CONTEXT_TYPE_pop_spec context )
{
    OracleCallProperties __oracle_properties;
    bool __res;
    if ( getCheckPrecondition() && !pre_pop_spec(
              context.params->inpar1
                     )
       )
    {
        destroy(context.params);
        trace_oracle_start_pop_spec( context.refId );
        traceException( PRECONDITION_FAILED_MESSAGE );
        traceOracleEnd();
        return OracleVerdict_PreconditionFailed;
    }
    __context_pop_spec = context;
    __oracle_properties.refId = __context_pop_spec.refId;

    __res = oracle_pop_spec(
              __mediator_pop_spec.parallel_mediator
             ,&__oracle_properties
             ,  context.params->inpar1
                   );
    destroy( __context_pop_spec.params );
    __context_pop_spec.params = (void*)0;
    return __oracle_properties.verdict ? OracleVerdict_Ok : OracleVerdict_PostconditionFailed;
}

bool call_active_oracle_pop_spec( int *item )
{
    CallProperties __properties;
    bool __res;
    String* tmp_;
    assertion( __mediator_pop_spec.sequential_mediator != (void*)0, "Mediator of pop_spec is not set up" );
    traceModelOperationStart( "stimulus", pop_spec->subsystem, pop_spec->signature );
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__ptr_to__int
                              , &item
                              );
    traceModelOperationArgument( "int *"
                               , "@item"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);

    switch (getTSMode())
    {
        case SequentialTSMode:
            {
                OracleCallProperties __oracle_properties;
                __oracle_properties.refId = -1;
                __res = oracle_pop_spec(
                           __mediator_pop_spec.sequential_mediator
                          ,&__oracle_properties
                         ,  item
                               );
                setOracleVerdict( __oracle_properties.verdict );
                break;
            }
        case ParallelTSMode:
        {
            PAR_RES_TYPE_pop_spec* __context;
            int *inpar1;

            ts_copy_sectype( (SECTypeDesc*)&__type_desc__ptr_to__int
                           , &inpar1
                           , &item
                           , 0
                           );

            __res = __mediator_pop_spec.call_mediator(
                      &__properties
                     ,  item
                                             );
            __context = create( &type_PAR_RES_TYPE_pop_spec
                     ,  inpar1
                     ,  item
                 , __res
                 );
            registerStimulus( "pop_spec", pop_spec, __context, __properties.time );

            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__ptr_to__int
                              , &inpar1
                              , 0
                              );

            setOracleVerdict( __properties.verdict );
            break;
        }
        default:
          assertion( 0, "Unexpected mode of the test system" );
    }
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__ptr_to__int
                              , &item
                              );
    traceModelOperationArgument( "int *"
                               , "item"
                               , toCharArray_String( r( tmp_ ) )
                               );
    destroy(tmp_);
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__bool, &__res );
    traceModelOperationResult( "bool"
                             , toCharArray_String(r(tmp_))
                             );
    destroy(tmp_);
    if( getTSMode() == ParallelTSMode )
    {
        traceModelOperationChannel(getStimulusChannel());
        ts_trace_model_operation_timestamp(__properties.time);
    }
    traceModelOperationEnd();
    return __res;
}

void trace_model_operation_pop_spec( InteractionId refId, PAR_RES_TYPE_pop_spec* params, ChannelID chid, TimeInterval timestamp )
{
    String* tmp_;
    traceModelOperationStart( "stimulus", pop_spec->subsystem, pop_spec->signature );
    traceModelOperationIdentifier(refId);
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__ptr_to__int, &params->inpar1 );
    traceModelOperationArgument( "int *"
                               , "@item"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);

    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__ptr_to__int, &params->outpar1 );
    traceModelOperationArgument( "int *"
                               , "item"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__bool, &params->res );
    traceModelOperationResult( "bool"
                             , toCharArray_String(r(tmp_))
                             );
    destroy(tmp_);
    traceModelOperationChannel(chid);
    ts_trace_model_operation_timestamp(timestamp);
    traceModelOperationEnd();
    destroy(params);
}

SpecificationDesc desc_pop_spec =
{
    "pop_spec",
    "",
    "bool pop_spec( int *item )",
    (PreFuncType)__pre_pop_spec,
    (CallPureOracleFuncType)call_pure_oracle_pop_spec,
    (TraceModelOperationFuncType)trace_model_operation_pop_spec,
    0,
    &type_PAR_RES_TYPE_pop_spec
};

SpecificationID pop_spec = &desc_pop_spec;



static SpecTypeDesc __type_desc__ref_List = 
{ specType
, ((void*)0)
, ((void*)0)
, &type_List
};

static SimpleTypeDesc __type_desc__int =
{ simpleType
, ((void*)0)
, ((void*)0)
, "int"
, sizeof (int)
, "  d"
};

static SimpleTypeDesc __type_desc__bool =
{ simpleType
, ((void*)0)
, ((void*)0)
, "bool"
, sizeof (bool)
, "  c"
};




static FieldDesc __fields_desc__struct_PAR_RES_TYPE_push_spec[] = 
{
    { "inpar1", ((char*)(&((struct PAR_RES_TYPE_push_spec*)0)->inpar1) - (char*)0), (SECTypeDesc*)&__type_desc__int },
    { "outpar1", ((char*)(&((struct PAR_RES_TYPE_push_spec*)0)->outpar1) - (char*)0), (SECTypeDesc*)&__type_desc__int },
    { "res", ((char*)(&((struct PAR_RES_TYPE_push_spec*)0)->res) - (char*)0), (SECTypeDesc*)&__type_desc__bool }
};

static StructTypeDesc __type_desc__struct_PAR_RES_TYPE_push_spec = 
{ structType
, ((void*)0)
, ((void*)0)
, "struct PAR_RES_TYPE_push_spec"
, sizeof( struct PAR_RES_TYPE_push_spec )
, 3
, __fields_desc__struct_PAR_RES_TYPE_push_spec
};





static PointerTypeDesc __type_desc__ptr_to__int =
{ pointerType
, ((void*)0)
, ((void*)0)
, 1
, (SECTypeDesc*)&__type_desc__int
};





static FieldDesc __fields_desc__struct_PAR_RES_TYPE_pop_spec[] = 
{
    { "inpar1", ((char*)(&((struct PAR_RES_TYPE_pop_spec*)0)->inpar1) - (char*)0), (SECTypeDesc*)&__type_desc__ptr_to__int },
    { "outpar1", ((char*)(&((struct PAR_RES_TYPE_pop_spec*)0)->outpar1) - (char*)0), (SECTypeDesc*)&__type_desc__ptr_to__int },
    { "res", ((char*)(&((struct PAR_RES_TYPE_pop_spec*)0)->res) - (char*)0), (SECTypeDesc*)&__type_desc__bool }
};

static StructTypeDesc __type_desc__struct_PAR_RES_TYPE_pop_spec = 
{ structType
, ((void*)0)
, ((void*)0)
, "struct PAR_RES_TYPE_pop_spec"
, sizeof( struct PAR_RES_TYPE_pop_spec )
, 3
, __fields_desc__struct_PAR_RES_TYPE_pop_spec
};




