/******************************************************************************/
/**                                                                          **/
/**  Generated by: sec 2.9.315-beta-110124                                   **/
/**  Date: Wed Sep 14 14:42:38 CST 2022                                      **/
/**                                                                          **/
/******************************************************************************/


#define va_start(ap,v)  __builtin_va_start(ap,v)
#define va_end(ap)      __builtin_va_end(ap)
#define va_arg(ap,t)    __builtin_va_arg(ap,t)

typedef void Object;
void _dummy( void * );

typedef unsigned int size_t;
extern void* memcpy(void *__restrict__ __dest, const void *__restrict__ __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern void* memmove(void * __dest, const void * __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern void* memset(void * __s, int  __c, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern int memcmp(const void * __s1, const void * __s2, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern void* memchr(const void * __s, int  __c, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern char* strcpy(char *__restrict__ __dest, const char *__restrict__ __src) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strncpy(char *__restrict__ __dest, const char *__restrict__ __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strcat(char *__restrict__ __dest, const char *__restrict__ __src) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strncat(char *__restrict__ __dest, const char *__restrict__ __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1, 2 )));
extern int strcmp(const char * __s1, const char * __s2) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern int strncmp(const char * __s1, const char * __s2, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern int strcoll(const char * __s1, const char * __s2) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern size_t strxfrm(char *__restrict__ __dest, const char *__restrict__ __src, size_t  __n) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 2 )));
extern char* strchr(const char * __s, int  __c) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern char* strrchr(const char * __s, int  __c) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern size_t strcspn(const char * __s, const char * __reject) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern size_t strspn(const char * __s, const char * __accept) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strpbrk(const char * __s, const char * __accept) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strstr(const char * __haystack, const char * __needle) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1, 2 )));
extern char* strtok(char *__restrict__ __s, const char *__restrict__ __delim) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 2 )));
extern char* __strtok_r(char *__restrict__ __s, const char *__restrict__ __delim, char * *__restrict__ __save_ptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 2, 3 )));
extern size_t strlen(const char * __s) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern char* strerror(int  __errnum) __attribute__(( __nothrow__, __leaf__));
typedef char bool;
typedef unsigned char __u_char;
typedef unsigned short int __u_short;
typedef unsigned int __u_int;
typedef unsigned long int __u_long;
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef signed short int __int16_t;
typedef unsigned short int __uint16_t;
typedef signed int __int32_t;
typedef unsigned int __uint32_t;
__extension__ typedef signed long long int __int64_t;
__extension__ typedef unsigned long long int __uint64_t;
__extension__ typedef long long int __quad_t;
__extension__ typedef unsigned long long int __u_quad_t;
__extension__ typedef long long int __intmax_t;
__extension__ typedef unsigned long long int __uintmax_t;
__extension__ typedef __u_quad_t __dev_t;
__extension__ typedef unsigned int __uid_t;
__extension__ typedef unsigned int __gid_t;
__extension__ typedef unsigned long int __ino_t;
__extension__ typedef __u_quad_t __ino64_t;
__extension__ typedef unsigned int __mode_t;
__extension__ typedef unsigned int __nlink_t;
__extension__ typedef long int __off_t;
__extension__ typedef __quad_t __off64_t;
__extension__ typedef int __pid_t;
__extension__ typedef struct 
{
    int  __val[2];

}
 __fsid_t;
__extension__ typedef long int __clock_t;
__extension__ typedef unsigned long int __rlim_t;
__extension__ typedef __u_quad_t __rlim64_t;
__extension__ typedef unsigned int __id_t;
__extension__ typedef long int __time_t;
__extension__ typedef unsigned int __useconds_t;
__extension__ typedef long int __suseconds_t;
__extension__ typedef int __daddr_t;
__extension__ typedef int __key_t;
__extension__ typedef int __clockid_t;
__extension__ typedef void* __timer_t;
__extension__ typedef long int __blksize_t;
__extension__ typedef long int __blkcnt_t;
__extension__ typedef __quad_t __blkcnt64_t;
__extension__ typedef unsigned long int __fsblkcnt_t;
__extension__ typedef __u_quad_t __fsblkcnt64_t;
__extension__ typedef unsigned long int __fsfilcnt_t;
__extension__ typedef __u_quad_t __fsfilcnt64_t;
__extension__ typedef int __fsword_t;
__extension__ typedef int __ssize_t;
__extension__ typedef long int __syscall_slong_t;
__extension__ typedef unsigned long int __syscall_ulong_t;
typedef __off64_t __loff_t;
typedef char* __caddr_t;
__extension__ typedef int __intptr_t;
__extension__ typedef unsigned int __socklen_t;
typedef int __sig_atomic_t;
struct  _IO_FILE
;
typedef struct  _IO_FILE
 __FILE;
struct  _IO_FILE
;
typedef struct  _IO_FILE
 FILE;
typedef struct 
{
    int  __count;

    union 
    {
        unsigned int  __wch;

        char  __wchb[4];

    }
      __value;

}
 __mbstate_t;
typedef struct 
{
    __off_t  __pos;

    __mbstate_t  __state;

}
 _G_fpos_t;
typedef struct 
{
    __off64_t  __pos;

    __mbstate_t  __state;

}
 _G_fpos64_t;
typedef __builtin_va_list __gnuc_va_list;
struct  _IO_jump_t
;
struct  _IO_FILE
;
typedef void _IO_lock_t;
struct  _IO_marker
{
    struct  _IO_marker
     * _next;

    struct  _IO_FILE
     * _sbuf;

    int  _pos;

}
;
enum  __codecvt_result
{
    __codecvt_ok, __codecvt_partial, __codecvt_error, __codecvt_noconv}

;
struct  _IO_FILE
{
    int  _flags;

    char * _IO_read_ptr;

    char * _IO_read_end;

    char * _IO_read_base;

    char * _IO_write_base;

    char * _IO_write_ptr;

    char * _IO_write_end;

    char * _IO_buf_base;

    char * _IO_buf_end;

    char * _IO_save_base;

    char * _IO_backup_base;

    char * _IO_save_end;

    struct  _IO_marker
     * _markers;

    struct  _IO_FILE
     * _chain;

    int  _fileno;

    int  _flags2;

    __off_t  _old_offset;

    unsigned short  _cur_column;

    signed char  _vtable_offset;

    char  _shortbuf[1];

    _IO_lock_t * _lock;

    __off64_t  _offset;

    void * __pad1;

    void * __pad2;

    void * __pad3;

    void * __pad4;

    size_t  __pad5;

    int  _mode;

    char  _unused2[15 * sizeof( int ) - 4 * sizeof( void * ) - sizeof( size_t )];

}
;
typedef struct  _IO_FILE
 _IO_FILE;
struct  _IO_FILE_plus
;
extern struct  _IO_FILE_plus
 _IO_2_1_stdin_;
extern struct  _IO_FILE_plus
 _IO_2_1_stdout_;
extern struct  _IO_FILE_plus
 _IO_2_1_stderr_;
typedef __ssize_t __io_read_fn(void * __cookie, char * __buf, size_t  __nbytes);
typedef __ssize_t __io_write_fn(void * __cookie, const char * __buf, size_t  __n);
typedef int __io_seek_fn(void * __cookie, __off64_t * __pos, int  __w);
typedef int __io_close_fn(void * __cookie);
extern int __underflow(_IO_FILE *);
extern int __uflow(_IO_FILE *);
extern int __overflow(_IO_FILE *, int);
extern int _IO_getc(_IO_FILE * __fp);
extern int _IO_putc(int  __c, _IO_FILE * __fp);
extern int _IO_feof(_IO_FILE * __fp) __attribute__(( __nothrow__, __leaf__));
extern int _IO_ferror(_IO_FILE * __fp) __attribute__(( __nothrow__, __leaf__));
extern int _IO_peekc_locked(_IO_FILE * __fp);
extern void _IO_flockfile(_IO_FILE *) __attribute__(( __nothrow__, __leaf__));
extern void _IO_funlockfile(_IO_FILE *) __attribute__(( __nothrow__, __leaf__));
extern int _IO_ftrylockfile(_IO_FILE *) __attribute__(( __nothrow__, __leaf__));
extern int _IO_vfscanf(_IO_FILE *__restrict__, const char *__restrict__, __gnuc_va_list, int *__restrict__);
extern int _IO_vfprintf(_IO_FILE *__restrict__, const char *__restrict__, __gnuc_va_list);
extern __ssize_t _IO_padn(_IO_FILE *, int, __ssize_t);
extern size_t _IO_sgetn(_IO_FILE *, void *, size_t);
extern __off64_t _IO_seekoff(_IO_FILE *, __off64_t, int, int);
extern __off64_t _IO_seekpos(_IO_FILE *, __off64_t, int);
extern void _IO_free_backup_area(_IO_FILE *) __attribute__(( __nothrow__, __leaf__));
typedef _G_fpos_t fpos_t;
extern struct  _IO_FILE
* stdin;
extern struct  _IO_FILE
* stdout;
extern struct  _IO_FILE
* stderr;
extern int remove(const char * __filename) __attribute__(( __nothrow__, __leaf__));
extern int rename(const char * __old, const char * __new) __attribute__(( __nothrow__, __leaf__));
extern FILE* tmpfile(void);
extern char* tmpnam(char * __s) __attribute__(( __nothrow__, __leaf__));
extern int fclose(FILE * __stream);
extern int fflush(FILE * __stream);
extern FILE* fopen(const char *__restrict__ __filename, const char *__restrict__ __modes);
extern FILE* freopen(const char *__restrict__ __filename, const char *__restrict__ __modes, FILE *__restrict__ __stream);
extern void setbuf(FILE *__restrict__ __stream, char *__restrict__ __buf) __attribute__(( __nothrow__, __leaf__));
extern int setvbuf(FILE *__restrict__ __stream, char *__restrict__ __buf, int  __modes, size_t  __n) __attribute__(( __nothrow__, __leaf__));
extern int fprintf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...);
extern int printf(const char *__restrict__ __format, ...);
extern int sprintf(char *__restrict__ __s, const char *__restrict__ __format, ...) __attribute__(( __nothrow__));
extern int vfprintf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg);
extern int vprintf(const char *__restrict__ __format, __gnuc_va_list  __arg);
extern int vsprintf(char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __nothrow__));
extern int snprintf(char *__restrict__ __s, size_t  __maxlen, const char *__restrict__ __format, ...) __attribute__(( __nothrow__)) __attribute__(( __format__( __printf__, 3, 4 )));
extern int vsnprintf(char *__restrict__ __s, size_t  __maxlen, const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __nothrow__)) __attribute__(( __format__( __printf__, 3, 0 )));
extern int fscanf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...);
extern int scanf(const char *__restrict__ __format, ...);
extern int sscanf(const char *__restrict__ __s, const char *__restrict__ __format, ...) __attribute__(( __nothrow__, __leaf__));
extern int fscanf(FILE *__restrict__ __stream, const char *__restrict__ __format, ...) __asm__(  """__isoc99_fscanf");
extern int scanf(const char *__restrict__ __format, ...) __asm__(  """__isoc99_scanf");
extern int sscanf(const char *__restrict__ __s, const char *__restrict__ __format, ...) __asm__(  """__isoc99_sscanf") __attribute__(( __nothrow__, __leaf__));
extern int vfscanf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __format__( __scanf__, 2, 0 )));
extern int vscanf(const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __format__( __scanf__, 1, 0 )));
extern int vsscanf(const char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __format__( __scanf__, 2, 0 )));
extern int vfscanf(FILE *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __asm__(  """__isoc99_vfscanf") __attribute__(( __format__( __scanf__, 2, 0 )));
extern int vscanf(const char *__restrict__ __format, __gnuc_va_list  __arg) __asm__(  """__isoc99_vscanf") __attribute__(( __format__( __scanf__, 1, 0 )));
extern int vsscanf(const char *__restrict__ __s, const char *__restrict__ __format, __gnuc_va_list  __arg) __asm__(  """__isoc99_vsscanf") __attribute__(( __nothrow__, __leaf__)) __attribute__(( __format__( __scanf__, 2, 0 )));
extern int fgetc(FILE * __stream);
extern int getc(FILE * __stream);
extern int getchar(void);
extern int fputc(int  __c, FILE * __stream);
extern int putc(int  __c, FILE * __stream);
extern int putchar(int  __c);
extern char* fgets(char *__restrict__ __s, int  __n, FILE *__restrict__ __stream);
extern char* gets(char * __s) __attribute__(( __deprecated__));
extern int fputs(const char *__restrict__ __s, FILE *__restrict__ __stream);
extern int puts(const char * __s);
extern int ungetc(int  __c, FILE * __stream);
extern size_t fread(void *__restrict__ __ptr, size_t  __size, size_t  __n, FILE *__restrict__ __stream);
extern size_t fwrite(const void *__restrict__ __ptr, size_t  __size, size_t  __n, FILE *__restrict__ __s);
extern int fseek(FILE * __stream, long int  __off, int  __whence);
extern long int ftell(FILE * __stream);
extern void rewind(FILE * __stream);
extern int fgetpos(FILE *__restrict__ __stream, fpos_t *__restrict__ __pos);
extern int fsetpos(FILE * __stream, const fpos_t * __pos);
extern void clearerr(FILE * __stream) __attribute__(( __nothrow__, __leaf__));
extern int feof(FILE * __stream) __attribute__(( __nothrow__, __leaf__));
extern int ferror(FILE * __stream) __attribute__(( __nothrow__, __leaf__));
extern void perror(const char * __s);
typedef long int wchar_t;
typedef struct 
{
    int  quot;

    int  rem;

}
 div_t;
typedef struct 
{
    long int  quot;

    long int  rem;

}
 ldiv_t;
__extension__ typedef struct 
{
    long long int  quot;

    long long int  rem;

}
 lldiv_t;
extern size_t __ctype_get_mb_cur_max(void) __attribute__(( __nothrow__, __leaf__));
extern double atof(const char * __nptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern int atoi(const char * __nptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern long int atol(const char * __nptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
__extension__ extern long long int atoll(const char * __nptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __pure__)) __attribute__(( __nonnull__( 1 )));
extern double strtod(const char *__restrict__ __nptr, char * *__restrict__ __endptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern float strtof(const char *__restrict__ __nptr, char * *__restrict__ __endptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern long double strtold(const char *__restrict__ __nptr, char * *__restrict__ __endptr) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern long int strtol(const char *__restrict__ __nptr, char * *__restrict__ __endptr, int  __base) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern unsigned long int strtoul(const char *__restrict__ __nptr, char * *__restrict__ __endptr, int  __base) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
__extension__ extern long long int strtoll(const char *__restrict__ __nptr, char * *__restrict__ __endptr, int  __base) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
__extension__ extern unsigned long long int strtoull(const char *__restrict__ __nptr, char * *__restrict__ __endptr, int  __base) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern int rand(void) __attribute__(( __nothrow__, __leaf__));
extern void srand(unsigned int  __seed) __attribute__(( __nothrow__, __leaf__));
extern void* malloc(size_t  __size) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __malloc__));
extern void* calloc(size_t  __nmemb, size_t  __size) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __malloc__));
extern void* realloc(void * __ptr, size_t  __size) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __warn_unused_result__));
extern void free(void * __ptr) __attribute__(( __nothrow__, __leaf__));
extern void abort(void) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __noreturn__));
extern int atexit(void  (* __func)(void)) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern void exit(int  __status) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __noreturn__));
extern void _Exit(int  __status) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __noreturn__));
extern char* getenv(const char * __name) __attribute__(( __nothrow__, __leaf__)) __attribute__(( __nonnull__( 1 )));
extern int system(const char * __command);
typedef int (* __compar_fn_t)(const void *, const void *);
extern void* bsearch(const void * __key, const void * __base, size_t  __nmemb, size_t  __size, __compar_fn_t  __compar) __attribute__(( __nonnull__( 1, 2, 5 )));
extern void qsort(void * __base, size_t  __nmemb, size_t  __size, __compar_fn_t  __compar) __attribute__(( __nonnull__( 1, 4 )));
extern int abs(int  __x) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern long int labs(long int  __x) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
__extension__ extern long long int llabs(long long int  __x) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern div_t div(int  __numer, int  __denom) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern ldiv_t ldiv(long int  __numer, long int  __denom) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
__extension__ extern lldiv_t lldiv(long long int  __numer, long long int  __denom) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern int mblen(const char * __s, size_t  __n) __attribute__(( __nothrow__, __leaf__));
extern int mbtowc(wchar_t *__restrict__ __pwc, const char *__restrict__ __s, size_t  __n) __attribute__(( __nothrow__, __leaf__));
extern int wctomb(char * __s, wchar_t  __wchar) __attribute__(( __nothrow__, __leaf__));
extern size_t mbstowcs(wchar_t *__restrict__ __pwcs, const char *__restrict__ __s, size_t  __n) __attribute__(( __nothrow__, __leaf__));
extern size_t wcstombs(char *__restrict__ __s, const wchar_t *__restrict__ __pwcs, size_t  __n) __attribute__(( __nothrow__, __leaf__));
typedef __gnuc_va_list va_list;
typedef void (* AssertionExit)(const char * format, va_list  args);
AssertionExit atAssertion(AssertionExit  func);
AssertionExit atFault(AssertionExit  func);
bool isCustomAssertionExit(void);
void assertion(int  expr, const char * format, ...);
void fault(int  expr, const char * format, ...);
typedef int ptrdiff_t;
typedef struct  Type
 Type;
 typedef struct  String
 String;

extern const Type type_String;


String* create_String(const char * cstr);
char charAt_String(String * self, int  index);
String* concat_String(String * self, String * str);
bool endsWith_String(String * self, String * suffix);
int indexOfChar_String(String * self, int  ch);
int indexOfCharFrom_String(String * self, int  ch, int  fromIndex);
int indexOfString_String(String * self, String * str);
int indexOfStringFrom_String(String * self, String * str, int  fromIndex);
int lastIndexOfChar_String(String * self, int  ch);
int lastIndexOfCharFrom_String(String * self, int  ch, int  fromIndex);
int lastIndexOfString_String(String * self, String * str);
int lastIndexOfStringFrom_String(String * self, String * str, int  fromIndex);
int length_String(String * self);
bool regionMatches_String(String * self, bool  ignoreCase, int  toffset, String * other, int  ooffset, int  len);
bool regionMatchesCase_String(String * self, int  toffset, String * other, int  ooffset, int  len);
String* replace_String(String * self, char  oldChar, char  newChar);
bool startsWith_String(String * self, String * prefix);
bool startsWithOffset_String(String * self, String * prefix, int  toffset);
String* substringFrom_String(String * self, int  beginIndex);
String* substring_String(String * self, int  beginIndex, int  endIndex);
const char* toCharArray_String(String * self);
String* toLowerCase_String(String * self);
String* toUpperCase_String(String * self);
String* trim_String(String * self);
String* format_String(const char * format, ...);
String* vformat_String(const char * format, va_list  args);
String* valueOfBool_String(bool  b);
String* valueOfChar_String(char  c);
String* valueOfShort_String(short  i);
String* valueOfUShort_String(unsigned short  i);
String* valueOfInt_String(int  i);
String* valueOfUInt_String(unsigned int  i);
String* valueOfLong_String(long  l);
String* valueOfULong_String(unsigned long  l);
String* valueOfFloat_String(float  f);
String* valueOfDouble_String(double  d);
String* valueOfPtr_String(void * p);
String* valueOfObject_String(Object * ref);
String* valueOfBytes_String(const char * p, int  l);
String* XML_encode_String(String * self);
int hash_String(String * str);
Object* r(Object * ref);
Object* r_weak(Object * ref);
Object* r_hard(Object * ref);
Object* r_hard2weak(Object * ref);
Object* r_weak2hard(Object * ref);
void r_take(Object * ref);
void r_release(Object * ref);
typedef void (* Init)(void * ref, va_list * arg_list);
typedef void (* Copy)(void * src, void * dst);
typedef int (* Compare)(void * left, void * right);
typedef String* (* ToString)(void * ref);
typedef String* (* ToXML)(void * ref);
typedef bool (* CheckInvariant)(Object * ref);
typedef bool (* EnumerationCallbackFuncType)(void * ref, void * par);
typedef void (* Enumerate)(void * ref, EnumerationCallbackFuncType  callback, void * par);
typedef void (* Destroy)(void * ref);
struct  Type
{
    const char * name;

    size_t  size;

    const Type * base;

    Init  init;

    Copy  copy;

    Compare  compare;

    ToString  to_string;

    ToXML  to_XML;

    CheckInvariant  check_invariant;

    Enumerate  enumerate;

    Destroy  destroy;

}
;
extern const Type type_Object;
const Type* type(Object * ref);
const Type* TYPE(Object * ref);
size_t size_Type(const Type * type);
bool isBasicType(const Type * type1, const Type * type2);
const Type* getMaximalType(const Type * type);
Object* create_Object(const Type *, ...);
Object* va_create_Object(const Type *, va_list * arg_list);
Object* create(const Type *, ...);
Object* va_create(const Type *, va_list * arg_list);
Object* clone_Object(Object * ref);
Object* clone(Object * ref);
void set_Object(Object * ref, ...);
void set(Object * ref, ...);
void copy_Object(Object * src, Object * dst);
void copy(Object * src, Object * dst);
int compare_Object(Object * left, Object * right);
int compare(Object * left, Object * right);
bool equals_Object(Object * self, Object * ref);
bool equals(Object * self, Object * ref);
String* toString_Object(Object * ref);
String* toString(Object * ref);
String* toTrace(Object * ref);
String* toXML_Object(Object * ref);
String* toXML(Object * ref);
String* to_XML_spec(const char * type, String * value);
String* toTrace(Object * ref);
bool checkInvariant_Object(Object * ref);
bool checkInvariant(Object * ref);
void detach_Object(Object * ref);
void destroy_Object(Object * ref);
void destroy(Object * ref);
void init_Default(Object * ref, va_list * arg_list);
void copy_Default(Object * src, Object * dst);
int compare_Default(Object * left, Object * right);
String* to_string_Default(Object * ref);
String* to_XML_Default(Object * ref);
bool check_invariant_Default(Object * ref);
void enumerate_Default(Object * ref, EnumerationCallbackFuncType  callback, void * par);
void destroy_Default(Object * ref);
void init_Subtype(Object * ref, va_list * arg_list);
void copy_Subtype(Object * src, Object * dst);
int compare_Subtype(Object * left, Object * right);
String* to_string_Subtype(Object * ref);
String* to_XML_Subtype(Object * ref);
void enumerate_Subtype(Object * ref, EnumerationCallbackFuncType  callback, void * par);
void destroy_Subtype(Object * ref);
typedef enum  SECTypeKind
{
    simpleType, structType, pointerType, arrayType, specType, subType}

 SECTypeKind;
typedef struct  SECTypeDesc
 SECTypeDesc;
struct  SECTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

}
;
typedef struct  SimpleTypeDesc
 SimpleTypeDesc;
struct  SimpleTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    const char * name;

    size_t  sizeOf;

    const char * format;

}
;
typedef struct  FieldDesc
 FieldDesc;
struct  FieldDesc
{
    const char * name;

    unsigned int  offset;

    SECTypeDesc * type_desc;

}
;
typedef struct  StructTypeDesc
 StructTypeDesc;
struct  StructTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    const char * name;

    size_t  sizeOf;

    int  numFields;

    FieldDesc * fields;

}
;
typedef struct  PointerTypeDesc
 PointerTypeDesc;
struct  PointerTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    int  level;

    SECTypeDesc * base;

}
;
typedef struct  ArrayTypeDesc
 ArrayTypeDesc;
struct  ArrayTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    size_t  sizeOfElement;

    int  numElements;

    SECTypeDesc * base;

}
;
typedef struct  SpecTypeDesc
 SpecTypeDesc;
struct  SpecTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    const Type * type;

}
;
typedef bool (* InvariantCheckerPtr)(void *);
typedef struct  SubTypeDesc
 SubTypeDesc;
struct  SubTypeDesc
{
    SECTypeKind  kind;

    ToString  customToString;

    ToXML  customToXML;

    const char * name;

    SECTypeDesc * base;

    InvariantCheckerPtr  invariant_checker;

}
;
SECTypeDesc* ts_base_type_desc(SECTypeDesc * type_desc);
void ts_start_copy_sectype();
void ts_copy_sectype(SECTypeDesc * desc, void * dst, void * src, bool  weak);
void ts_finish_copy_sectype();
bool ts_equals_sectype(SECTypeDesc * desc, void * left, void * right);
String* ts_to_string_sectype(SECTypeDesc * desc, void * ptr);
String* ts_to_XML_sectype(SECTypeDesc * desc, void * ptr);
String* ts_to_trace_sectype(SECTypeDesc * desc, void * ptr);
bool ts_start_to_XML();
String* create_single_XML_entry(const char * kind, const char * type, String * value);
void ts_finish_to_XML();
bool ts_check_invariant_sectype(SECTypeDesc * desc, void * ptr);
void ts_enumerate_sectype(SECTypeDesc * desc, void * ptr, EnumerationCallbackFuncType  callback, void * par);
void ts_start_destroy_sectype();
void ts_destroy_sectype(SECTypeDesc * desc, void * ptr, bool  weak);
void ts_finish_destroy_sectype();
typedef __int8_t int8_t;
typedef __int16_t int16_t;
typedef __int32_t int32_t;
typedef __int64_t int64_t;
typedef __uint8_t uint8_t;
typedef __uint16_t uint16_t;
typedef __uint32_t uint32_t;
typedef __uint64_t uint64_t;
typedef signed char int_least8_t;
typedef short int int_least16_t;
typedef int int_least32_t;
__extension__ typedef long long int int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short int uint_least16_t;
typedef unsigned int uint_least32_t;
__extension__ typedef unsigned long long int uint_least64_t;
typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
__extension__ typedef long long int int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
__extension__ typedef unsigned long long int uint_fast64_t;
typedef int intptr_t;
typedef unsigned int uintptr_t;
typedef __intmax_t intmax_t;
typedef __uintmax_t uintmax_t;
typedef long ChannelID;
extern const ChannelID WrongChannel;
extern const ChannelID UniqueChannel;
ChannelID getChannelID(void);
void releaseChannelID(ChannelID  chid);
typedef uint64_t LinearTimeMark;
typedef int TimeFrameOfReferenceID;
extern const TimeFrameOfReferenceID infiniteTimeFrameOfReferenceID;
extern const TimeFrameOfReferenceID systemTimeFrameOfReferenceID;
TimeFrameOfReferenceID getTimeFrameOfReferenceID(const char * name);
bool setSystemTimeFrameOfReferenceName(const char * name);
typedef struct  TimeMark
 TimeMark;
struct  TimeMark
{
    TimeFrameOfReferenceID  frame;

    LinearTimeMark  timemark;

}
;
extern const TimeMark minTimeMark;
extern const TimeMark maxTimeMark;
TimeMark createTimeMark(LinearTimeMark  timemark);
TimeMark createDistributedTimeMark(TimeFrameOfReferenceID  frame, LinearTimeMark  timemark);
void setTimeMarkDependence(TimeMark  former, TimeMark  latter);
typedef enum  CompareResult
{
    EqualCR, LessCR, GreaterCR, NonComparableCR}

 CompareResult;
CompareResult compareTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool equalTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool lessTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool lessOrEqualTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool greaterTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool greaterOrEqualTimeMarks(TimeMark  tm1, TimeMark  tm2);
bool noncomparableTimeMarks(TimeMark  tm1, TimeMark  tm2);
typedef int64_t TimeUnit;
TimeUnit diffTimeMarks(TimeMark  tm1, TimeMark  tm2);
TimeMark addTimeMarks(TimeMark  tm, TimeUnit  delta);
TimeMark subtractTimeMarks(TimeMark  tm, TimeUnit  delta);
typedef struct  TimeInterval
 TimeInterval;
struct  TimeInterval
{
    TimeMark  minMark;

    TimeMark  maxMark;

}
;
extern const TimeInterval overallTimeInterval;
TimeInterval createTimeInterval(TimeMark  minMark, TimeMark  maxMark);
bool areIntersectedTimeIntervals(TimeInterval  ti1, TimeInterval  ti2);
TimeInterval addTimeIntervals(TimeInterval  ti, TimeUnit  delta);
TimeInterval subtractTimeIntervals(TimeInterval  ti, TimeUnit  delta);
int printLinearTimeInterval(char * buffer, TimeInterval  interval);
int printDistributedTimeInterval(char * buffer, TimeInterval  interval);
bool setAutomaticTimeMarksMode(bool  enable);
bool areAutomaticTimeMarksEnabled(void);
TimeMark getCurrentTimeMark(void);
typedef TimeMark (* GetCurrentTimeMarkFuncType)(void);
GetCurrentTimeMarkFuncType setDefaultCurrentTimeMarkFunction(GetCurrentTimeMarkFuncType  new_func);
void setAutomaticTimeMark(TimeMark * timemark);
typedef enum  TSTimeModel
{
    NotUseTSTime, LinearTSTime, DistributedTSTime}

 TSTimeModel;
TSTimeModel setTSTimeModel(TSTimeModel  time_model);
TSTimeModel getTSTimeModel(void);
typedef struct  CallProperties
 CallProperties;
struct  CallProperties
{
    bool  verdict;

    TimeInterval  time;

}
;
typedef long InteractionId;
typedef struct  OracleCallProperties
 OracleCallProperties;
struct  OracleCallProperties
{
    InteractionId  refId;

    bool  verdict;

}
;
void setOracleVerdict(bool  verdict);
bool getOracleVerdict(void);
void clearOracleVerdict(void);
typedef enum  OracleVerdict
{
    OracleVerdict_Ok, OracleVerdict_PreconditionFailed, OracleVerdict_PostconditionFailed}

 OracleVerdict;
typedef struct  CallContextStruct
{
    Object * params;

    TimeInterval  time;

    InteractionId  refId;

}
 CallContextType;
typedef bool (* PreFuncType)(Object * params);
typedef OracleVerdict (* CallPureOracleFuncType)(CallContextType);
typedef void (* TraceModelOperationFuncType)(InteractionId, Object *, ChannelID, TimeInterval);
typedef struct  SpecificationDesc
{
    const char * name;

    const char * subsystem;

    const char * signature;

    PreFuncType  precondition;

    CallPureOracleFuncType  call_pure_oracle;

    TraceModelOperationFuncType  trace_model_operation;

    bool  is_reaction;

    const Type * par_res_type;

}
 SpecificationDesc;
typedef SpecificationDesc* SpecificationID;
typedef Object* (* PtrActionInit)(void);
typedef bool (* PtrActionHasNext)(Object *);
typedef bool (* PtrActionNext)(Object *);
typedef bool (* PtrActionCall)(Object *);
typedef struct 
{
    PtrActionInit  init;

    PtrActionHasNext  has_next;

    PtrActionNext  next;

    PtrActionCall  call;

    const char * name;

}
 ScenarioFunctionDesc;
typedef ScenarioFunctionDesc* ScenarioFunctionID;
void ts_trace_model_operation_timestamp(TimeInterval  timestamp);
void ts_trace_bad_oracle_verdict(void);
void ts_trace_bad_mediator_verdict(void);
Object* * ts_cast_spec_ref_lvalue(const Type * type, Object * * ref);
Object* ts_cast_spec_ref(const Type * type, Object * ref);
Object* ts_check_spec_ref(const Type * type, Object * ref, const char * kind, const char * where);
Object* ts_assign_spec_ref(Object * * left, Object * right, const char * where);
void* ts_destroy_spec_ref(Object * ref);
void _dummy(void * p);
Object* singletonState(void);
void setCheckPrecondition(bool  check);
bool getCheckPrecondition(void);
void setCheckPostcondition(bool  check);
bool getCheckPostcondition(void);
extern const char PRECONDITION_FAILED_MESSAGE[];
extern const char POSTCONDITION_FAILED_MESSAGE[];
extern const char SCENARIO_FUNCTION_FAILED_MESSAGE[];
extern const char INCORRECT_SET_OF_INTERACTIONS_MESSAGE[];
extern const char MEDIATOR_FAILED_MESSAGE[];
extern const char UNCONNECTED_GRAPH_MESSAGE[];
extern const char NONDETERMINISTIC_GRAPH_MESSAGE[];
extern const char SCENARIO_INITIALIZATION_FAILED_MESSAGE[];
extern const char SERIALIZATION_FAILED_MESSAGE[];
extern const char NONSTATIONARY_STATE_MESSAGE[];
void registerReaction(ChannelID  chid, const char * name, SpecificationID  reactionID, Object * data);
void registerReactionWithTimeMark(ChannelID  chid, const char * name, SpecificationID  reactionID, Object * data, TimeMark  mark);
void registerReactionWithTimeInterval(ChannelID  chid, const char * name, SpecificationID  reactionID, Object * data, TimeInterval  interval);
void registerWrongReaction(const char * info);
typedef bool (* ReactionCatcherFuncType)(void *);
void registerReactionCatcher(ReactionCatcherFuncType  catcher, void * par);
bool unregisterReactionCatcher(ReactionCatcherFuncType  catcher, void * par);
bool unregisterReactionCatchers(ReactionCatcherFuncType  catcher);
ChannelID setStimulusChannel(ChannelID  chid);
ChannelID getStimulusChannel(void);
void registerStimulus(const char * name, SpecificationID  stimulusID, Object * data, TimeInterval  interval);
void registerStimulusWithTimeInterval(ChannelID  chid, const char * name, SpecificationID  stimulusID, TimeInterval  interval, ...);
typedef __clock_t clock_t;
typedef __time_t time_t;
struct  tm
{
    int  tm_sec;

    int  tm_min;

    int  tm_hour;

    int  tm_mday;

    int  tm_mon;

    int  tm_year;

    int  tm_wday;

    int  tm_yday;

    int  tm_isdst;

    long int  __tm_gmtoff;

    const char * __tm_zone;

}
;
extern clock_t clock(void) __attribute__(( __nothrow__, __leaf__));
extern time_t time(time_t * __timer) __attribute__(( __nothrow__, __leaf__));
extern double difftime(time_t  __time1, time_t  __time0) __attribute__(( __nothrow__, __leaf__)) __attribute__(( const));
extern time_t mktime(struct  tm
 * __tp) __attribute__(( __nothrow__, __leaf__));
extern size_t strftime(char *__restrict__ __s, size_t  __maxsize, const char *__restrict__ __format, const struct  tm
 *__restrict__ __tp) __attribute__(( __nothrow__, __leaf__));
extern struct  tm
* gmtime(const time_t * __timer) __attribute__(( __nothrow__, __leaf__));
extern struct  tm
* localtime(const time_t * __timer) __attribute__(( __nothrow__, __leaf__));
extern char* asctime(const struct  tm
 * __tp) __attribute__(( __nothrow__, __leaf__));
extern char* ctime(const time_t * __timer) __attribute__(( __nothrow__, __leaf__));
extern char* __tzname[2];
extern int __daylight;
extern long int __timezone;
typedef enum 
{
    TD_ok, TD_bad_parameters, TD_not_enough_resources, TD_bad_verdict, TD_faulted, ORACLE_bad_verdict}

 TestVerdict;
extern TestVerdict testVerdict;
typedef enum 
{
    UNTIL_ERROR, UNTIL_END}

 FinishMode;
FinishMode setFinishMode(FinishMode  finish_mode);
FinishMode getFinishMode(void);
int setNumberOfErrorsToFinish(int  error_number);
typedef enum  TSMode
{
    SequentialTSMode, ParallelTSMode}

 TSMode;
TSMode getTSMode(void);
bool setDeferredReactionsMode(bool  enable);
bool areDeferredReactionsEnabled(void);
time_t setWTime(time_t  secs);
time_t setWTimeMSec(time_t  millisecs);
time_t getWTime(void);
time_t getWTimeMSec(void);
bool setFindFirstSeriesOnly(bool  new_value);
bool isFindFirstSeriesOnly(void);
int setFindFirstSeriesOnlyBound(int  bound);
int getFindFirstSeriesOnlyBound(void);
void ts_assert_function(const char * format, va_list  arg_list);
bool startTestSystem(int  argc, char * * argv);
void stopTestSystem(void);
const char* getCurrentTestScenarioName(void);
typedef bool (* PtrIsStationaryState)(void);
typedef Object* (* PtrSaveModelState)(void);
typedef void (* PtrRestoreModelState)(Object *);
typedef void (* PtrObserveState)(void);
typedef void (* PtrDoneEvent)(void);
typedef struct  ModelStateManager
{
    PtrSaveModelState  saveModelState;

    PtrRestoreModelState  restoreModelState;

    PtrIsStationaryState  isStationaryState;

    PtrObserveState  observeState;

}
 ModelStateManager;
typedef bool (* TS_Init)(int, char * *);
typedef void (* TS_Finish)(void);
typedef Object* (* TS_GetState)(void);
typedef String* (* TS_GetStateId)(Object *);
typedef bool (* TS_IsStationaryState)(void);
typedef Object* (* TS_SaveModelState)(void);
typedef void (* TS_RestoreModelState)(Object *);
typedef void (* TS_ObserveState)(void);
typedef struct  TestScenario
{
    const char * name;

    TS_Init  init;

    TS_GetState  getState;

    TS_GetStateId  getStateId;

    TS_SaveModelState  saveModelState;

    TS_RestoreModelState  restoreModelState;

    TS_IsStationaryState  isStationaryState;

    TS_ObserveState  observeState;

    TS_Finish  finish;

    ScenarioFunctionID * actions;

}
 TestScenario;
String* getStateId_Default(Object * obj);
typedef bool (* PtrInit)(int, char * *);
typedef void (* PtrFinish)(void);
typedef Object* (* PtrGetState)(void);
typedef String* (* PtrGetStateId)(Object *);
typedef TestScenario dfsm;
bool start_dfsm(int  argc, char * * argv, dfsm * td);
typedef TestScenario ndfsm;
bool start_ndfsm(int  argc, char * * argv, ndfsm * test);
 typedef void Unit;

extern const Type type_Unit;


Unit* create_Unit();
typedef int c_bool;
void setTraceUserEnv(const char * name, const char * value);
void setTraceEncoding(const char * encoding);
void setTraceDataFormatXML();
void setTraceDataFormatString();
c_bool addTraceToConsole(void);
c_bool removeTraceToConsole(void);
c_bool addTraceToFile(const char * name);
c_bool removeTraceToFile(const char * name);
c_bool isTraceEnabled(void);
c_bool setTraceAccidental(c_bool  enable);
void startTrace(void);
void endTrace(void);
void traceScenarioStart(const char * name);
void traceScenarioParameters(int  argc, const char * * argv);
void traceTestEngineProperty(const char * name, const char * value);
void traceScenarioEnd(void);
void traceScenarioValue(const char * kind, const char * type, const char * name, const char * value);
void traceState(const char * id);
void traceTransitionStart(const char * id);
void traceTransitionEnd(void);
void traceModelOperationStart(const char * kind, const char * subsystem, const char * signature);
void traceModelOperationArgument(const char * type, const char * name, const char * value);
void traceModelOperationResult(const char * type, const char * value);
void traceModelOperationIdentifier(long  id);
void traceModelOperationChannel(long  chid);
void traceModelOperationTimestamp(const char * timestamp);
void traceOracleStart(const char * subsystem, const char * signature, long  refId);
void tracePreconditionEnd(void);
void traceOracleEnd(void);
void traceModelOperationEnd(void);
void traceSeriesStart(void);
void traceSeriesEnd(void);
void tracePrimeFormula(int  id, c_bool  value);
void traceCoverageElement(const char * structureId, const char * coverageId, int  branchId);
void traceMark(const char * mark);
void traceCoverageStructureStart(const char * name);
void traceFormulaeStart(void);
void traceFormula(int  id, const char * text);
void traceFormulaeEnd(void);
void traceCoverageStart(const char * id);
void traceElement(int  id, const char * name);
void traceCoverageEnd(void);
void traceCoverageStructureEnd(void);
void traceException(const char * kind);
void traceInterimException(const char * kind);
void traceExceptionValue(const char * name, const char * value);
void traceExceptionInfo(const char * info);
void traceInternalError(const char * info);
void traceSystemInfo(const char * info);
void traceUserInfo(const char * info);
void traceFormattedUserInfo(const char * format, ...);
c_bool isInTrace(void);
c_bool isInScenario(void);
c_bool isInTransition(void);
c_bool isInSeries(void);
c_bool isInModelOperation(void);
c_bool isInOracle(void);
c_bool isInPrecondition(void);
c_bool isInCoverageStructure(void);
c_bool isInFormulae(void);
c_bool isInCoverage(void);
int getTraceId(void);
void flushTrace(void);
void closeTrace(void);
typedef const char* CoverageText;
typedef int CoverageElement;
typedef enum 
{
    PRIMARY_COVERAGE, DOMAIN_VARIATION_COVERAGE, MULTIPLICATION_COVERAGE}

 COVERAGE_KIND;
typedef struct  _CoverageDesc
{
    COVERAGE_KIND  kind;

    int  size;

    int  base_num;

    int  order;

    bool  is_global;

    int  last_trace_id;

    CoverageText  name;

    CoverageElement  (* calc)();

    bool  (* filter)(CoverageElement);

    const void * data[];

}
 CoverageDesc;
extern int _CE_OUT_OF_COVERAGE;
const CoverageDesc* cov_component(const CoverageDesc * cov_desc, int  a);
CoverageElement ce_product(const CoverageDesc * cov_desc, ...);
CoverageElement ce_coord(const CoverageDesc * cov_desc, CoverageElement  element, int  axis, CoverageDesc * * p_prim_cov_desc);
CoverageText ce_txt(const CoverageDesc * cov_desc, CoverageElement  elem);
bool isElementInCoverage(const CoverageDesc * cov_desc, int  element);
void traceReachedCoverageElement(CoverageDesc * cov_desc, int  element);
void traceCoverageStructure(CoverageDesc * cov_desc);
const char* ts_get_ctesk_version(void);
const char* ts_get_ctesk_build(void);
void setBadVerdict(const char * msg);
bool isBadVerdict(void);
void clearBadVerdict(void);
enum  TS_Verdict
{
    TS_VERDICT_PRE = 1, TS_VERDICT_POST = 2, TS_VERDICT_MEDIATOR = 4, TS_VERDICT_SCENARIO = 8, TS_VERDICT_ALL = 15}

;
typedef void (* VerdictEventHandler)(bool  verdict);
void ts_set_verdict_event_handler(enum  TS_Verdict  ts_verdict_flags, VerdictEventHandler  handler);
void ts_fire_verdict_event(enum  TS_Verdict  ts_verdict_flag, bool  verdict);
typedef struct  Account
{
    int  balance;

}
 Account;
void deposit(Account * acct, int  sum);
int withdraw(Account * acct, int  sum);
extern  int MaximalCredit;
bool invariant_var_MaximalCredit(void);
 typedef Account AccountModel;
bool invariant_type_AccountModel( AccountModel* );
#ifndef PAR_RES_TYPE_deposit_spec_DEFINED
#define PAR_RES_TYPE_deposit_spec_DEFINED

struct PAR_RES_TYPE_deposit_spec
{
AccountModel *inpar1;
AccountModel *outpar1;
int inpar2;
int outpar2;
};

typedef struct PAR_RES_TYPE_deposit_spec PAR_RES_TYPE_deposit_spec;
extern const Type type_PAR_RES_TYPE_deposit_spec;

#endif

#ifndef CONTEXT_TYPE_deposit_spec_DEFINED
#define CONTEXT_TYPE_deposit_spec_DEFINED

typedef
struct CONTEXT_TYPE_deposit_spec
{
  PAR_RES_TYPE_deposit_spec* params;
  TimeInterval  time;
  InteractionId refId;
} CONTEXT_TYPE_deposit_spec;

#endif

extern CONTEXT_TYPE_deposit_spec __context_deposit_spec;

#ifndef MEDIATOR_deposit_spec_DEFINED
#define MEDIATOR_deposit_spec_DEFINED
  typedef void (*MEDIATOR_FUNC_deposit_spec)( CallProperties*, AccountModel *acct, int sum );
  typedef struct MEDIATOR_deposit_spec
   {
    MEDIATOR_FUNC_deposit_spec sequential_mediator;
    MEDIATOR_FUNC_deposit_spec call_mediator;
    MEDIATOR_FUNC_deposit_spec parallel_mediator;
   } 
  MEDIATOR_deposit_spec;
#endif

MEDIATOR_deposit_spec set_mediator_deposit_spec( MEDIATOR_deposit_spec m );

bool pre_deposit_spec( AccountModel *acct, int sum );

void oracle_deposit_spec( MEDIATOR_FUNC_deposit_spec __media, OracleCallProperties* __oracle_properties, AccountModel *acct, int sum );

OracleVerdict call_pure_oracle_deposit_spec( CONTEXT_TYPE_deposit_spec context );

void call_active_oracle_deposit_spec( AccountModel *acct, int sum );

extern SpecificationID deposit_spec;

#ifndef PAR_RES_TYPE_withdraw_spec_DEFINED
#define PAR_RES_TYPE_withdraw_spec_DEFINED

struct PAR_RES_TYPE_withdraw_spec
{
AccountModel *inpar1;
AccountModel *outpar1;
int inpar2;
int outpar2;
int res;
};

typedef struct PAR_RES_TYPE_withdraw_spec PAR_RES_TYPE_withdraw_spec;
extern const Type type_PAR_RES_TYPE_withdraw_spec;

#endif

#ifndef CONTEXT_TYPE_withdraw_spec_DEFINED
#define CONTEXT_TYPE_withdraw_spec_DEFINED

typedef
struct CONTEXT_TYPE_withdraw_spec
{
  PAR_RES_TYPE_withdraw_spec* params;
  TimeInterval  time;
  InteractionId refId;
} CONTEXT_TYPE_withdraw_spec;

#endif

extern CONTEXT_TYPE_withdraw_spec __context_withdraw_spec;

#ifndef MEDIATOR_withdraw_spec_DEFINED
#define MEDIATOR_withdraw_spec_DEFINED
  typedef int (*MEDIATOR_FUNC_withdraw_spec)( CallProperties*, AccountModel *acct, int sum );
  typedef struct MEDIATOR_withdraw_spec
   {
    MEDIATOR_FUNC_withdraw_spec sequential_mediator;
    MEDIATOR_FUNC_withdraw_spec call_mediator;
    MEDIATOR_FUNC_withdraw_spec parallel_mediator;
   } 
  MEDIATOR_withdraw_spec;
#endif

MEDIATOR_withdraw_spec set_mediator_withdraw_spec( MEDIATOR_withdraw_spec m );

bool pre_withdraw_spec( AccountModel *acct, int sum );

int oracle_withdraw_spec( MEDIATOR_FUNC_withdraw_spec __media, OracleCallProperties* __oracle_properties, AccountModel *acct, int sum );

OracleVerdict call_pure_oracle_withdraw_spec( CONTEXT_TYPE_withdraw_spec context );

int call_active_oracle_withdraw_spec( AccountModel *acct, int sum );

extern SpecificationID withdraw_spec;

 int MaximalCredit = 3;
bool invariant_var_MaximalCredit(void);
bool invariant_var_MaximalCredit(void)
{
    {
        bool __res = 0;
        int __up = 0, __cmd = -3;
        _dummy( &__up ); _dummy( &__cmd );
        {
            { __res = (MaximalCredit >= 0); goto __destroy_body; }


        }

    goto __destroy_body;
    __destroy_body:;
        return __res;
    }
}
bool invariant_type_AccountModel(AccountModel* acct)
{
    {
        bool __res = 0;
        int __up = 0, __cmd = -3;
        _dummy( &__up ); _dummy( &__cmd );
        {
            { __res = ((*acct).balance >= -MaximalCredit); goto __destroy_body; }


        }

    goto __destroy_body;
    __destroy_body:;
        return __res;
    }
}
static PointerTypeDesc __type_desc__ptr_to__AccountModel;

static SimpleTypeDesc __type_desc__int;

extern SpecificationID deposit_spec;

#ifndef PAR_RES_TYPE_deposit_spec_DEFINED
#define PAR_RES_TYPE_deposit_spec_DEFINED

struct PAR_RES_TYPE_deposit_spec
{
AccountModel *inpar1;
AccountModel *outpar1;
int inpar2;
int outpar2;
};

typedef struct PAR_RES_TYPE_deposit_spec PAR_RES_TYPE_deposit_spec;
extern const Type type_PAR_RES_TYPE_deposit_spec;

#endif

static StructTypeDesc __type_desc__struct_PAR_RES_TYPE_deposit_spec;

static void init_PAR_RES_TYPE_deposit_spec( struct PAR_RES_TYPE_deposit_spec *obj, va_list* arg_list )
{
    {
        AccountModel *__tmp;
        __tmp = va_arg( *arg_list, AccountModel * );
        ts_copy_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                       , &obj->inpar1
                       , &__tmp
                       , 1
                       );
    }
    obj->inpar2 = va_arg( *arg_list, int );
    {
        AccountModel *__tmp;
        __tmp = va_arg( *arg_list, AccountModel * );
        ts_copy_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                       , &obj->outpar1
                       , &__tmp
                       , 1
                       );
    }
    obj->outpar2 = va_arg( *arg_list, int );
}

static void copy_PAR_RES_TYPE_deposit_spec( struct PAR_RES_TYPE_deposit_spec *src, struct PAR_RES_TYPE_deposit_spec *dst )
{
    ts_copy_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_deposit_spec
                   , dst
                   , src
                   , 1
                   );
}

static int compare_PAR_RES_TYPE_deposit_spec( struct PAR_RES_TYPE_deposit_spec *left, struct PAR_RES_TYPE_deposit_spec *right )
{
    if( ts_equals_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_deposit_spec, left, right ) )
      return 0;
    return 1;
}

static String* to_string_PAR_RES_TYPE_deposit_spec( struct PAR_RES_TYPE_deposit_spec *obj )
{
    return ts_to_string_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_deposit_spec, obj );
}

static String* to_XML_PAR_RES_TYPE_deposit_spec( struct PAR_RES_TYPE_deposit_spec *obj )
{
    return ts_to_XML_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_deposit_spec, obj );
}

static void destroy_PAR_RES_TYPE_deposit_spec( struct PAR_RES_TYPE_deposit_spec *obj )
{
    ts_destroy_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_deposit_spec, obj, 1 );
}

const Type type_PAR_RES_TYPE_deposit_spec =
{
  "PAR_RES_TYPE_deposit_spec",
  sizeof(struct PAR_RES_TYPE_deposit_spec),
  &type_Object,
  (Init)init_PAR_RES_TYPE_deposit_spec,
  (Copy)copy_PAR_RES_TYPE_deposit_spec,
  (Compare)compare_PAR_RES_TYPE_deposit_spec,
  (ToString)to_string_PAR_RES_TYPE_deposit_spec,
  (ToXML)to_XML_PAR_RES_TYPE_deposit_spec,
  (CheckInvariant)check_invariant_Default,
  (Enumerate)enumerate_Default,
  (Destroy)destroy_PAR_RES_TYPE_deposit_spec
};


#ifndef CONTEXT_TYPE_deposit_spec_DEFINED
#define CONTEXT_TYPE_deposit_spec_DEFINED

typedef
struct CONTEXT_TYPE_deposit_spec
{
  PAR_RES_TYPE_deposit_spec* params;
  TimeInterval  time;
  InteractionId refId;
} CONTEXT_TYPE_deposit_spec;

#endif

CONTEXT_TYPE_deposit_spec __context_deposit_spec;

#ifndef MEDIATOR_deposit_spec_DEFINED
#define MEDIATOR_deposit_spec_DEFINED
  typedef void (*MEDIATOR_FUNC_deposit_spec)( CallProperties*, AccountModel *acct, int sum );
  typedef struct MEDIATOR_deposit_spec
   {
    MEDIATOR_FUNC_deposit_spec sequential_mediator;
    MEDIATOR_FUNC_deposit_spec call_mediator;
    MEDIATOR_FUNC_deposit_spec parallel_mediator;
   } 
  MEDIATOR_deposit_spec;
#endif

static MEDIATOR_deposit_spec __mediator_deposit_spec;

MEDIATOR_deposit_spec set_mediator_deposit_spec( MEDIATOR_deposit_spec m )
{
  MEDIATOR_deposit_spec old_m = __mediator_deposit_spec;
  __mediator_deposit_spec = m;
  return old_m;
}

bool pre_deposit_spec( AccountModel *acct, int sum )
{
    bool pre = 1;
    if( pre )
    {
        pre = ts_check_invariant_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                                        , &acct
                                        );
    }
    if (pre)
    {
        bool __alias1_has_value = 
                 1;
        bool balance_has_value = 
                 (acct != (void*)0);
        _dummy( &__alias1_has_value );
        _dummy( &balance_has_value );
        if (pre)
        {
            int __up = 0, __cmd = -3;
            _dummy( &__up ); _dummy( &__cmd );
            {
                {
                    { pre = ((acct != ((void *)0)) && (sum > 0) && ((*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) <= 0x7fffffff - sum)); goto __after_pre; }


                }
            __after_pre:
                ;




            }

        }
    }
    return pre;
}

static bool __pre_deposit_spec( PAR_RES_TYPE_deposit_spec* params )
{
    bool res = pre_deposit_spec(
              params->inpar1
             ,params->inpar2
    );
    destroy(params);
    return res;
}

CoverageElement _local_cov_calc_deposit_spec( unsigned int _cov_num, AccountModel *acct, int sum );


CoverageElement _cov_calc_deposit_spec_C( AccountModel *acct, int sum );

CoverageDesc _cov_desc_deposit_spec_C =
{ PRIMARY_COVERAGE
, 5
, 0
, 1
, 0
, -1
, "C"
, &_cov_calc_deposit_spec_C
, 0
, { "Maximal deposition"
  , "Positive balance"
  , "Minimal balance"
  , "Negative balance"
  , "Empty account"
  }
};

#ifndef _COV_STRUCT_deposit_spec_C
#define _COV_STRUCT_deposit_spec_C

struct _cov_struct_deposit_spec_C
{
    const int maximum;
    const int positive;
    const int minimum;
    const int negative;
    const int zero;
    CoverageDesc* desc;
};

#endif

struct _cov_struct_deposit_spec_C deposit_spec_C = 
{ 0
, 1
, 2
, 3
, 4
, &_cov_desc_deposit_spec_C
};

CoverageElement _cov_calc_deposit_spec_C( AccountModel *acct, int sum )
{
    CoverageElement __res = _CE_OUT_OF_COVERAGE;
    int __up = 0, __cmd = -3;
    _dummy( &__up ); _dummy( &__cmd );
    __res = _local_cov_calc_deposit_spec
        ( 0 ,  acct
                 ,sum
         );
    return __res;
}

CoverageElement _local_cov_calc_deposit_spec( unsigned int _cov_num, AccountModel *acct, int sum )
{
    bool pre = 1;
    int _cov_values[ 1 ];
    assertion( _cov_num < 1
             , "_local_cov_calc_deposit_spec: illegal _cov_num"
             );
    if( pre )
    {
        pre = ts_check_invariant_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                                        , &acct
                                        );
    }
    if( pre )
    {
        bool __alias1_has_value = 
                 1;
        bool balance_has_value = 
                 (acct != (void*)0);
        _dummy( &__alias1_has_value );
        _dummy( &balance_has_value );
        if( pre )
        {
            int __up = 0, __cmd = -3;
            _dummy( &__up ); _dummy( &__cmd );
            {
                {
                    { pre = ((acct != ((void *)0)) && (sum > 0) && ((*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) <= 0x7fffffff - sum)); goto __after_pre; }


                }
            __after_pre:

                if ( pre )
                {
                    // calculation of coverage 'C'
                    _cov_values[ 0 /* C */ ] = _CE_OUT_OF_COVERAGE;
                    {
                        if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) + sum == 0x7fffffff )
                        {
                            {
                              _cov_values[ 0 /* C */ ] = deposit_spec_C.maximum;
                              goto __after_coverage_deposit_spec_C;
                            }
                        }
                        else
                        {
                            if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) > 0 )
                            {
                                {
                                  _cov_values[ 0 /* C */ ] = deposit_spec_C.positive;
                                  goto __after_coverage_deposit_spec_C;
                                }
                            }
                            else
                            {
                                if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) < 0 )
                                {
                                    if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) == -MaximalCredit )
                                    {
                                        {
                                          _cov_values[ 0 /* C */ ] = deposit_spec_C.minimum;
                                          goto __after_coverage_deposit_spec_C;
                                        }
                                    }
                                    else
                                    {
                                        {
                                          _cov_values[ 0 /* C */ ] = deposit_spec_C.negative;
                                          goto __after_coverage_deposit_spec_C;
                                        }
                                    }
                                }
                                else
                                {
                                    {
                                      _cov_values[ 0 /* C */ ] = deposit_spec_C.zero;
                                      goto __after_coverage_deposit_spec_C;
                                    }
                                }
                            }
                        }


                    }
                __after_coverage_deposit_spec_C: ;

                }


            }

        }
    }
    if( !pre ) return _CE_OUT_OF_COVERAGE;
    return _cov_values[ _cov_num ];
}

void trace_info_deposit_spec(void)
{
    traceCoverageStructureStart( "" );
    traceCoverageStructure( deposit_spec_C.desc );
    traceFormulaeStart();
    traceFormula( 0, "invariant type AccountModel * (@acct)" );
    traceFormula( 1, "invariant type AccountModel * (acct)" );
    traceFormulaeEnd();
    traceCoverageStructureEnd();
}

void trace_oracle_start_deposit_spec(InteractionId refId)
{
    static int last_trace_id = -1;

    traceOracleStart( deposit_spec->subsystem, deposit_spec->signature, refId );

    if( last_trace_id < getTraceId() )
    {
        last_trace_id = getTraceId();
        trace_info_deposit_spec();
    }
}

void oracle_deposit_spec( MEDIATOR_FUNC_deposit_spec __media, OracleCallProperties* __oracle_properties, AccountModel *acct, int sum )
{
    bool pre = 1;
    CoverageElement _cov_val_deposit_spec_C = _CE_OUT_OF_COVERAGE;
    CallProperties __properties;

    assertion( __media != (void*)0,  "Mediator of deposit_spec is not set up");
    assertion( __oracle_properties != (void*)0, "Oracle properties cannot be NULL");

    __oracle_properties->verdict = 1;
    trace_oracle_start_deposit_spec( __oracle_properties->refId );

    if( pre )
    {
        pre = ts_check_invariant_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                                        , &acct
                                        );
        tracePrimeFormula( 0, pre );
        if (!pre) traceSystemInfo( "Invariant of acct failed" );
    }
    assertion(pre, PRECONDITION_FAILED_MESSAGE);
    {
        bool __alias1_has_value = 
                 1;
        bool balance_has_value = 
                 (acct != (void*)0);
        bool __pre_expr_0_has_value = 0;
        int __pre_expr_0;
        _dummy( &__alias1_has_value );
        _dummy( &balance_has_value );
        assertion(pre, PRECONDITION_FAILED_MESSAGE);
        {
            int __up = 0, __cmd = -3;
            _dummy( &__up ); _dummy( &__cmd );
            {
                if( getCheckPrecondition() )
                {
                    { pre = ((acct != ((void *)0)) && (sum > 0) && ((*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) <= 0x7fffffff - sum)); goto __after_pre; }


                }
            __after_pre:
                assertion(pre, PRECONDITION_FAILED_MESSAGE);
                tracePreconditionEnd();

                // calculation of coverage 'C'
                {
                    if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) + sum == 0x7fffffff )
                    {
                        {
                          _cov_val_deposit_spec_C = deposit_spec_C.maximum;
                          goto __after_coverage_deposit_spec_C;
                        }
                    }
                    else
                    {
                        if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) > 0 )
                        {
                            {
                              _cov_val_deposit_spec_C = deposit_spec_C.positive;
                              goto __after_coverage_deposit_spec_C;
                            }
                        }
                        else
                        {
                            if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) < 0 )
                            {
                                if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) == -MaximalCredit )
                                {
                                    {
                                      _cov_val_deposit_spec_C = deposit_spec_C.minimum;
                                      goto __after_coverage_deposit_spec_C;
                                    }
                                }
                                else
                                {
                                    {
                                      _cov_val_deposit_spec_C = deposit_spec_C.negative;
                                      goto __after_coverage_deposit_spec_C;
                                    }
                                }
                            }
                            else
                            {
                                {
                                  _cov_val_deposit_spec_C = deposit_spec_C.zero;
                                  goto __after_coverage_deposit_spec_C;
                                }
                            }
                        }
                    }


                }
            __after_coverage_deposit_spec_C: ;
                traceReachedCoverageElement( deposit_spec_C.desc, _cov_val_deposit_spec_C );

                __pre_expr_0_has_value = 
                         1;
                ts_start_copy_sectype();
                if (__pre_expr_0_has_value)
                {
                    int __tmp_var = (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) );
                    ts_copy_sectype( (SECTypeDesc*)&__type_desc__int
                                   , &__pre_expr_0
                                   , &__tmp_var
                                   , 0
                                   );
                }
                ts_finish_copy_sectype();
                __media( &__properties
                         ,  acct
                         ,sum
                       );
                __oracle_properties->verdict = __properties.verdict;
                if( getCheckPostcondition() && __oracle_properties->verdict )
                {
                    {
                        {
                           __oracle_properties->verdict = ((*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) == (assertion( __pre_expr_0_has_value, "Incorrect value of '@balance'" ), __pre_expr_0) + sum);
                           goto __after_post;
                        }


                    }
                __after_post:
                    if (!__oracle_properties->verdict)
                      ts_trace_bad_oracle_verdict();
                }


            }

        }
        ts_start_destroy_sectype();
        if( __pre_expr_0_has_value )
        {
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__int
                              , &__pre_expr_0
                              , 0
                              );
        }
        ts_finish_destroy_sectype();
    }
    traceOracleEnd();
}

OracleVerdict call_pure_oracle_deposit_spec( CONTEXT_TYPE_deposit_spec context )
{
    OracleCallProperties __oracle_properties;
    if ( getCheckPrecondition() && !pre_deposit_spec(
              context.params->inpar1
             ,context.params->inpar2
                     )
       )
    {
        destroy(context.params);
        trace_oracle_start_deposit_spec( context.refId );
        traceException( PRECONDITION_FAILED_MESSAGE );
        traceOracleEnd();
        return OracleVerdict_PreconditionFailed;
    }
    __context_deposit_spec = context;
    __oracle_properties.refId = __context_deposit_spec.refId;

    oracle_deposit_spec(
              __mediator_deposit_spec.parallel_mediator
             ,&__oracle_properties
             ,  context.params->inpar1
             ,context.params->inpar2
                   );
    destroy( __context_deposit_spec.params );
    __context_deposit_spec.params = (void*)0;
    return __oracle_properties.verdict ? OracleVerdict_Ok : OracleVerdict_PostconditionFailed;
}

void call_active_oracle_deposit_spec( AccountModel *acct, int sum )
{
    CallProperties __properties;
    String* tmp_;
    assertion( __mediator_deposit_spec.sequential_mediator != (void*)0, "Mediator of deposit_spec is not set up" );
    traceModelOperationStart( "stimulus", deposit_spec->subsystem, deposit_spec->signature );
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                              , &acct
                              );
    traceModelOperationArgument( "AccountModel *"
                               , "@acct"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__int
                              , &sum
                              );
    traceModelOperationArgument( "int"
                               , "sum"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);

    switch (getTSMode())
    {
        case SequentialTSMode:
            {
                OracleCallProperties __oracle_properties;
                __oracle_properties.refId = -1;
                oracle_deposit_spec(
                           __mediator_deposit_spec.sequential_mediator
                          ,&__oracle_properties
                         ,  acct
                         ,sum
                               );
                setOracleVerdict( __oracle_properties.verdict );
                break;
            }
        case ParallelTSMode:
        {
            PAR_RES_TYPE_deposit_spec* __context;
            AccountModel *inpar1;
            int inpar2;

            ts_start_copy_sectype();
            ts_copy_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                           , &inpar1
                           , &acct
                           , 0
                           );
            ts_copy_sectype( (SECTypeDesc*)&__type_desc__int
                           , &inpar2
                           , &sum
                           , 0
                           );
            ts_finish_copy_sectype();

            __mediator_deposit_spec.call_mediator(
                      &__properties
                     ,  acct
                     ,sum
                                             );
            __context = create( &type_PAR_RES_TYPE_deposit_spec
                     ,  inpar1
                     ,inpar2
                     ,  acct
                     ,sum
                 );
            registerStimulus( "deposit_spec", deposit_spec, __context, __properties.time );

            ts_start_destroy_sectype();
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                              , &inpar1
                              , 0
                              );
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__int
                              , &inpar2
                              , 0
                              );
            ts_finish_destroy_sectype();

            setOracleVerdict( __properties.verdict );
            break;
        }
        default:
          assertion( 0, "Unexpected mode of the test system" );
    }
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                              , &acct
                              );
    traceModelOperationArgument( "AccountModel *"
                               , "acct"
                               , toCharArray_String( r( tmp_ ) )
                               );
    destroy(tmp_);
    if( getTSMode() == ParallelTSMode )
    {
        traceModelOperationChannel(getStimulusChannel());
        ts_trace_model_operation_timestamp(__properties.time);
    }
    traceModelOperationEnd();
}

void trace_model_operation_deposit_spec( InteractionId refId, PAR_RES_TYPE_deposit_spec* params, ChannelID chid, TimeInterval timestamp )
{
    String* tmp_;
    traceModelOperationStart( "stimulus", deposit_spec->subsystem, deposit_spec->signature );
    traceModelOperationIdentifier(refId);
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel, &params->inpar1 );
    traceModelOperationArgument( "AccountModel *"
                               , "@acct"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__int, &params->inpar2 );
    traceModelOperationArgument( "int"
                               , "sum"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);

    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel, &params->outpar1 );
    traceModelOperationArgument( "AccountModel *"
                               , "acct"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);
    traceModelOperationChannel(chid);
    ts_trace_model_operation_timestamp(timestamp);
    traceModelOperationEnd();
    destroy(params);
}

SpecificationDesc desc_deposit_spec =
{
    "deposit_spec",
    "",
    "void deposit_spec( AccountModel *acct, int sum )",
    (PreFuncType)__pre_deposit_spec,
    (CallPureOracleFuncType)call_pure_oracle_deposit_spec,
    (TraceModelOperationFuncType)trace_model_operation_deposit_spec,
    0,
    &type_PAR_RES_TYPE_deposit_spec
};

SpecificationID deposit_spec = &desc_deposit_spec;

extern SpecificationID withdraw_spec;

#ifndef PAR_RES_TYPE_withdraw_spec_DEFINED
#define PAR_RES_TYPE_withdraw_spec_DEFINED

struct PAR_RES_TYPE_withdraw_spec
{
AccountModel *inpar1;
AccountModel *outpar1;
int inpar2;
int outpar2;
int res;
};

typedef struct PAR_RES_TYPE_withdraw_spec PAR_RES_TYPE_withdraw_spec;
extern const Type type_PAR_RES_TYPE_withdraw_spec;

#endif

static StructTypeDesc __type_desc__struct_PAR_RES_TYPE_withdraw_spec;

static void init_PAR_RES_TYPE_withdraw_spec( struct PAR_RES_TYPE_withdraw_spec *obj, va_list* arg_list )
{
    {
        AccountModel *__tmp;
        __tmp = va_arg( *arg_list, AccountModel * );
        ts_copy_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                       , &obj->inpar1
                       , &__tmp
                       , 1
                       );
    }
    obj->inpar2 = va_arg( *arg_list, int );
    {
        AccountModel *__tmp;
        __tmp = va_arg( *arg_list, AccountModel * );
        ts_copy_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                       , &obj->outpar1
                       , &__tmp
                       , 1
                       );
    }
    obj->outpar2 = va_arg( *arg_list, int );
    obj->res = va_arg( *arg_list, int );
}

static void copy_PAR_RES_TYPE_withdraw_spec( struct PAR_RES_TYPE_withdraw_spec *src, struct PAR_RES_TYPE_withdraw_spec *dst )
{
    ts_copy_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_withdraw_spec
                   , dst
                   , src
                   , 1
                   );
}

static int compare_PAR_RES_TYPE_withdraw_spec( struct PAR_RES_TYPE_withdraw_spec *left, struct PAR_RES_TYPE_withdraw_spec *right )
{
    if( ts_equals_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_withdraw_spec, left, right ) )
      return 0;
    return 1;
}

static String* to_string_PAR_RES_TYPE_withdraw_spec( struct PAR_RES_TYPE_withdraw_spec *obj )
{
    return ts_to_string_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_withdraw_spec, obj );
}

static String* to_XML_PAR_RES_TYPE_withdraw_spec( struct PAR_RES_TYPE_withdraw_spec *obj )
{
    return ts_to_XML_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_withdraw_spec, obj );
}

static void destroy_PAR_RES_TYPE_withdraw_spec( struct PAR_RES_TYPE_withdraw_spec *obj )
{
    ts_destroy_sectype( (SECTypeDesc*)&__type_desc__struct_PAR_RES_TYPE_withdraw_spec, obj, 1 );
}

const Type type_PAR_RES_TYPE_withdraw_spec =
{
  "PAR_RES_TYPE_withdraw_spec",
  sizeof(struct PAR_RES_TYPE_withdraw_spec),
  &type_Object,
  (Init)init_PAR_RES_TYPE_withdraw_spec,
  (Copy)copy_PAR_RES_TYPE_withdraw_spec,
  (Compare)compare_PAR_RES_TYPE_withdraw_spec,
  (ToString)to_string_PAR_RES_TYPE_withdraw_spec,
  (ToXML)to_XML_PAR_RES_TYPE_withdraw_spec,
  (CheckInvariant)check_invariant_Default,
  (Enumerate)enumerate_Default,
  (Destroy)destroy_PAR_RES_TYPE_withdraw_spec
};


#ifndef CONTEXT_TYPE_withdraw_spec_DEFINED
#define CONTEXT_TYPE_withdraw_spec_DEFINED

typedef
struct CONTEXT_TYPE_withdraw_spec
{
  PAR_RES_TYPE_withdraw_spec* params;
  TimeInterval  time;
  InteractionId refId;
} CONTEXT_TYPE_withdraw_spec;

#endif

CONTEXT_TYPE_withdraw_spec __context_withdraw_spec;

#ifndef MEDIATOR_withdraw_spec_DEFINED
#define MEDIATOR_withdraw_spec_DEFINED
  typedef int (*MEDIATOR_FUNC_withdraw_spec)( CallProperties*, AccountModel *acct, int sum );
  typedef struct MEDIATOR_withdraw_spec
   {
    MEDIATOR_FUNC_withdraw_spec sequential_mediator;
    MEDIATOR_FUNC_withdraw_spec call_mediator;
    MEDIATOR_FUNC_withdraw_spec parallel_mediator;
   } 
  MEDIATOR_withdraw_spec;
#endif

static MEDIATOR_withdraw_spec __mediator_withdraw_spec;

MEDIATOR_withdraw_spec set_mediator_withdraw_spec( MEDIATOR_withdraw_spec m )
{
  MEDIATOR_withdraw_spec old_m = __mediator_withdraw_spec;
  __mediator_withdraw_spec = m;
  return old_m;
}

bool pre_withdraw_spec( AccountModel *acct, int sum )
{
    bool pre = 1;
    if( pre )
    {
        pre = ts_check_invariant_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                                        , &acct
                                        );
    }
    if (pre)
    {
        bool __alias1_has_value = 
                 1;
        bool balance_has_value = 
                 (acct != (void*)0);
        _dummy( &__alias1_has_value );
        _dummy( &balance_has_value );
        if (pre)
        {
            int __up = 0, __cmd = -3;
            _dummy( &__up ); _dummy( &__cmd );
            {
                {
                    { pre = ((acct != ((void *)0)) && (sum > 0)); goto __after_pre; }


                }
            __after_pre:
                ;




            }

        }
    }
    return pre;
}

static bool __pre_withdraw_spec( PAR_RES_TYPE_withdraw_spec* params )
{
    bool res = pre_withdraw_spec(
              params->inpar1
             ,params->inpar2
    );
    destroy(params);
    return res;
}

CoverageElement _local_cov_calc_withdraw_spec( unsigned int _cov_num, AccountModel *acct, int sum );


CoverageElement _cov_calc_withdraw_spec_C( AccountModel *acct, int sum );

CoverageDesc _cov_desc_withdraw_spec_C =
{ PRIMARY_COVERAGE
, 7
, 0
, 1
, 0
, -1
, "C"
, &_cov_calc_withdraw_spec_C
, 0
, { "Maximal withdrawal"
  , "Positive balance. Too large withdrawal"
  , "Positive balance. Successful withdrawal"
  , "Negative balance. Too large withdrawal"
  , "Negative balance. Successful withdrawal"
  , "Empty account. Too large withdrawal"
  , "Empty account. Successful withdrawal"
  }
};

#ifndef _COV_STRUCT_withdraw_spec_C
#define _COV_STRUCT_withdraw_spec_C

struct _cov_struct_withdraw_spec_C
{
    const int max_withdrawal;
    const int pos_too_large;
    const int positive_ok;
    const int neg_too_large;
    const int negative_ok;
    const int zero_too_large;
    const int zero_ok;
    CoverageDesc* desc;
};

#endif

struct _cov_struct_withdraw_spec_C withdraw_spec_C = 
{ 0
, 1
, 2
, 3
, 4
, 5
, 6
, &_cov_desc_withdraw_spec_C
};

CoverageElement _cov_calc_withdraw_spec_C( AccountModel *acct, int sum )
{
    CoverageElement __res = _CE_OUT_OF_COVERAGE;
    int __up = 0, __cmd = -3;
    _dummy( &__up ); _dummy( &__cmd );
    __res = _local_cov_calc_withdraw_spec
        ( 0 ,  acct
                 ,sum
         );
    return __res;
}

CoverageElement _local_cov_calc_withdraw_spec( unsigned int _cov_num, AccountModel *acct, int sum )
{
    bool pre = 1;
    int _cov_values[ 1 ];
    assertion( _cov_num < 1
             , "_local_cov_calc_withdraw_spec: illegal _cov_num"
             );
    if( pre )
    {
        pre = ts_check_invariant_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                                        , &acct
                                        );
    }
    if( pre )
    {
        bool __alias1_has_value = 
                 1;
        bool balance_has_value = 
                 (acct != (void*)0);
        _dummy( &__alias1_has_value );
        _dummy( &balance_has_value );
        if( pre )
        {
            int __up = 0, __cmd = -3;
            _dummy( &__up ); _dummy( &__cmd );
            {
                {
                    { pre = ((acct != ((void *)0)) && (sum > 0)); goto __after_pre; }


                }
            __after_pre:

                if ( pre )
                {
                    // calculation of coverage 'C'
                    _cov_values[ 0 /* C */ ] = _CE_OUT_OF_COVERAGE;
                    {
                        if( sum == 0x7fffffff )
                        {
                            {
                              _cov_values[ 0 /* C */ ] = withdraw_spec_C.max_withdrawal;
                              goto __after_coverage_withdraw_spec_C;
                            }
                        }

                        if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) > 0 )
                        {
                            if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) < sum - MaximalCredit )
                            {
                                {
                                  _cov_values[ 0 /* C */ ] = withdraw_spec_C.pos_too_large;
                                  goto __after_coverage_withdraw_spec_C;
                                }
                            }
                            else
                            {
                                {
                                  _cov_values[ 0 /* C */ ] = withdraw_spec_C.positive_ok;
                                  goto __after_coverage_withdraw_spec_C;
                                }
                            }
                        }
                        else
                        {
                            if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) < 0 )
                            {
                                if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) < sum - MaximalCredit )
                                {
                                    {
                                      _cov_values[ 0 /* C */ ] = withdraw_spec_C.neg_too_large;
                                      goto __after_coverage_withdraw_spec_C;
                                    }
                                }
                                else
                                {
                                    {
                                      _cov_values[ 0 /* C */ ] = withdraw_spec_C.negative_ok;
                                      goto __after_coverage_withdraw_spec_C;
                                    }
                                }
                            }
                            else
                            {
                                if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) < sum - MaximalCredit )
                                {
                                    {
                                      _cov_values[ 0 /* C */ ] = withdraw_spec_C.zero_too_large;
                                      goto __after_coverage_withdraw_spec_C;
                                    }
                                }
                                else
                                {
                                    {
                                      _cov_values[ 0 /* C */ ] = withdraw_spec_C.zero_ok;
                                      goto __after_coverage_withdraw_spec_C;
                                    }
                                }
                            }
                        }


                    }
                __after_coverage_withdraw_spec_C: ;

                }


            }

        }
    }
    if( !pre ) return _CE_OUT_OF_COVERAGE;
    return _cov_values[ _cov_num ];
}

void trace_info_withdraw_spec(void)
{
    traceCoverageStructureStart( "" );
    traceCoverageStructure( withdraw_spec_C.desc );
    traceFormulaeStart();
    traceFormula( 0, "invariant type AccountModel * (@acct)" );
    traceFormula( 1, "invariant type AccountModel * (acct)" );
    traceFormulaeEnd();
    traceCoverageStructureEnd();
}

void trace_oracle_start_withdraw_spec(InteractionId refId)
{
    static int last_trace_id = -1;

    traceOracleStart( withdraw_spec->subsystem, withdraw_spec->signature, refId );

    if( last_trace_id < getTraceId() )
    {
        last_trace_id = getTraceId();
        trace_info_withdraw_spec();
    }
}

int oracle_withdraw_spec( MEDIATOR_FUNC_withdraw_spec __media, OracleCallProperties* __oracle_properties, AccountModel *acct, int sum )
{
    bool pre = 1;
    CoverageElement _cov_val_withdraw_spec_C = _CE_OUT_OF_COVERAGE;
    CallProperties __properties;
    int __res;

    assertion( __media != (void*)0,  "Mediator of withdraw_spec is not set up");
    assertion( __oracle_properties != (void*)0, "Oracle properties cannot be NULL");

    __oracle_properties->verdict = 1;
    trace_oracle_start_withdraw_spec( __oracle_properties->refId );

    if( pre )
    {
        pre = ts_check_invariant_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                                        , &acct
                                        );
        tracePrimeFormula( 0, pre );
        if (!pre) traceSystemInfo( "Invariant of acct failed" );
    }
    assertion(pre, PRECONDITION_FAILED_MESSAGE);
    {
        bool __alias1_has_value = 
                 1;
        bool balance_has_value = 
                 (acct != (void*)0);
        bool __pre_expr_0_has_value = 0;
        int __pre_expr_0;
        bool __pre_expr_1_has_value = 0;
        int __pre_expr_1;
        bool __pre_expr_2_has_value = 0;
        int __pre_expr_2;
        _dummy( &__alias1_has_value );
        _dummy( &balance_has_value );
        assertion(pre, PRECONDITION_FAILED_MESSAGE);
        {
            int __up = 0, __cmd = -3;
            _dummy( &__up ); _dummy( &__cmd );
            {
                if( getCheckPrecondition() )
                {
                    { pre = ((acct != ((void *)0)) && (sum > 0)); goto __after_pre; }


                }
            __after_pre:
                assertion(pre, PRECONDITION_FAILED_MESSAGE);
                tracePreconditionEnd();

                // calculation of coverage 'C'
                {
                    if( sum == 0x7fffffff )
                    {
                        {
                          _cov_val_withdraw_spec_C = withdraw_spec_C.max_withdrawal;
                          goto __after_coverage_withdraw_spec_C;
                        }
                    }

                    if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) > 0 )
                    {
                        if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) < sum - MaximalCredit )
                        {
                            {
                              _cov_val_withdraw_spec_C = withdraw_spec_C.pos_too_large;
                              goto __after_coverage_withdraw_spec_C;
                            }
                        }
                        else
                        {
                            {
                              _cov_val_withdraw_spec_C = withdraw_spec_C.positive_ok;
                              goto __after_coverage_withdraw_spec_C;
                            }
                        }
                    }
                    else
                    {
                        if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) < 0 )
                        {
                            if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) < sum - MaximalCredit )
                            {
                                {
                                  _cov_val_withdraw_spec_C = withdraw_spec_C.neg_too_large;
                                  goto __after_coverage_withdraw_spec_C;
                                }
                            }
                            else
                            {
                                {
                                  _cov_val_withdraw_spec_C = withdraw_spec_C.negative_ok;
                                  goto __after_coverage_withdraw_spec_C;
                                }
                            }
                        }
                        else
                        {
                            if( (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) < sum - MaximalCredit )
                            {
                                {
                                  _cov_val_withdraw_spec_C = withdraw_spec_C.zero_too_large;
                                  goto __after_coverage_withdraw_spec_C;
                                }
                            }
                            else
                            {
                                {
                                  _cov_val_withdraw_spec_C = withdraw_spec_C.zero_ok;
                                  goto __after_coverage_withdraw_spec_C;
                                }
                            }
                        }
                    }


                }
            __after_coverage_withdraw_spec_C: ;
                traceReachedCoverageElement( withdraw_spec_C.desc, _cov_val_withdraw_spec_C );

                __pre_expr_0_has_value = 
                         1;
                __pre_expr_1_has_value = 
                         1;
                __pre_expr_2_has_value = 
                         1;
                ts_start_copy_sectype();
                if (__pre_expr_0_has_value)
                {
                    int __tmp_var = (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) );
                    ts_copy_sectype( (SECTypeDesc*)&__type_desc__int
                                   , &__pre_expr_0
                                   , &__tmp_var
                                   , 0
                                   );
                }
                if (__pre_expr_1_has_value)
                {
                    int __tmp_var = (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) );
                    ts_copy_sectype( (SECTypeDesc*)&__type_desc__int
                                   , &__pre_expr_1
                                   , &__tmp_var
                                   , 0
                                   );
                }
                if (__pre_expr_2_has_value)
                {
                    int __tmp_var = (*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) );
                    ts_copy_sectype( (SECTypeDesc*)&__type_desc__int
                                   , &__pre_expr_2
                                   , &__tmp_var
                                   , 0
                                   );
                }
                ts_finish_copy_sectype();
                __res = __media( &__properties
                         ,  acct
                         ,sum
                       );
                __oracle_properties->verdict = __properties.verdict;
                if( getCheckPostcondition() && __oracle_properties->verdict )
                {
                    {
                        if( (assertion( __pre_expr_0_has_value, "Incorrect value of '@balance'" ), __pre_expr_0) < sum - MaximalCredit )
                        {
                            {
                               __oracle_properties->verdict = ((*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) == (assertion( __pre_expr_1_has_value, "Incorrect value of '@balance'" ), __pre_expr_1) && __res == 0);
                               goto __after_post;
                            }
                        }
                        else
                        {
                            {
                               __oracle_properties->verdict = ((*( assertion( balance_has_value && (acct != (void*)0), "balance is not accessible" ), &acct->balance ) ) == (assertion( __pre_expr_2_has_value, "Incorrect value of '@balance'" ), __pre_expr_2) - sum && __res == sum);
                               goto __after_post;
                            }
                        }


                    }
                __after_post:
                    if (!__oracle_properties->verdict)
                      ts_trace_bad_oracle_verdict();
                }


            }

        }
        ts_start_destroy_sectype();
        if( __pre_expr_0_has_value )
        {
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__int
                              , &__pre_expr_0
                              , 0
                              );
        }
        if( __pre_expr_1_has_value )
        {
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__int
                              , &__pre_expr_1
                              , 0
                              );
        }
        if( __pre_expr_2_has_value )
        {
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__int
                              , &__pre_expr_2
                              , 0
                              );
        }
        ts_finish_destroy_sectype();
    }
    traceOracleEnd();
    return __res;
}

OracleVerdict call_pure_oracle_withdraw_spec( CONTEXT_TYPE_withdraw_spec context )
{
    OracleCallProperties __oracle_properties;
    int __res;
    if ( getCheckPrecondition() && !pre_withdraw_spec(
              context.params->inpar1
             ,context.params->inpar2
                     )
       )
    {
        destroy(context.params);
        trace_oracle_start_withdraw_spec( context.refId );
        traceException( PRECONDITION_FAILED_MESSAGE );
        traceOracleEnd();
        return OracleVerdict_PreconditionFailed;
    }
    __context_withdraw_spec = context;
    __oracle_properties.refId = __context_withdraw_spec.refId;

    __res = oracle_withdraw_spec(
              __mediator_withdraw_spec.parallel_mediator
             ,&__oracle_properties
             ,  context.params->inpar1
             ,context.params->inpar2
                   );
    destroy( __context_withdraw_spec.params );
    __context_withdraw_spec.params = (void*)0;
    return __oracle_properties.verdict ? OracleVerdict_Ok : OracleVerdict_PostconditionFailed;
}

int call_active_oracle_withdraw_spec( AccountModel *acct, int sum )
{
    CallProperties __properties;
    int __res;
    String* tmp_;
    assertion( __mediator_withdraw_spec.sequential_mediator != (void*)0, "Mediator of withdraw_spec is not set up" );
    traceModelOperationStart( "stimulus", withdraw_spec->subsystem, withdraw_spec->signature );
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                              , &acct
                              );
    traceModelOperationArgument( "AccountModel *"
                               , "@acct"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__int
                              , &sum
                              );
    traceModelOperationArgument( "int"
                               , "sum"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);

    switch (getTSMode())
    {
        case SequentialTSMode:
            {
                OracleCallProperties __oracle_properties;
                __oracle_properties.refId = -1;
                __res = oracle_withdraw_spec(
                           __mediator_withdraw_spec.sequential_mediator
                          ,&__oracle_properties
                         ,  acct
                         ,sum
                               );
                setOracleVerdict( __oracle_properties.verdict );
                break;
            }
        case ParallelTSMode:
        {
            PAR_RES_TYPE_withdraw_spec* __context;
            AccountModel *inpar1;
            int inpar2;

            ts_start_copy_sectype();
            ts_copy_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                           , &inpar1
                           , &acct
                           , 0
                           );
            ts_copy_sectype( (SECTypeDesc*)&__type_desc__int
                           , &inpar2
                           , &sum
                           , 0
                           );
            ts_finish_copy_sectype();

            __res = __mediator_withdraw_spec.call_mediator(
                      &__properties
                     ,  acct
                     ,sum
                                             );
            __context = create( &type_PAR_RES_TYPE_withdraw_spec
                     ,  inpar1
                     ,inpar2
                     ,  acct
                     ,sum
                 , __res
                 );
            registerStimulus( "withdraw_spec", withdraw_spec, __context, __properties.time );

            ts_start_destroy_sectype();
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                              , &inpar1
                              , 0
                              );
            ts_destroy_sectype( (SECTypeDesc*)&__type_desc__int
                              , &inpar2
                              , 0
                              );
            ts_finish_destroy_sectype();

            setOracleVerdict( __properties.verdict );
            break;
        }
        default:
          assertion( 0, "Unexpected mode of the test system" );
    }
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel
                              , &acct
                              );
    traceModelOperationArgument( "AccountModel *"
                               , "acct"
                               , toCharArray_String( r( tmp_ ) )
                               );
    destroy(tmp_);
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__int, &__res );
    traceModelOperationResult( "int"
                             , toCharArray_String(r(tmp_))
                             );
    destroy(tmp_);
    if( getTSMode() == ParallelTSMode )
    {
        traceModelOperationChannel(getStimulusChannel());
        ts_trace_model_operation_timestamp(__properties.time);
    }
    traceModelOperationEnd();
    return __res;
}

void trace_model_operation_withdraw_spec( InteractionId refId, PAR_RES_TYPE_withdraw_spec* params, ChannelID chid, TimeInterval timestamp )
{
    String* tmp_;
    traceModelOperationStart( "stimulus", withdraw_spec->subsystem, withdraw_spec->signature );
    traceModelOperationIdentifier(refId);
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel, &params->inpar1 );
    traceModelOperationArgument( "AccountModel *"
                               , "@acct"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__int, &params->inpar2 );
    traceModelOperationArgument( "int"
                               , "sum"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);

    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__ptr_to__AccountModel, &params->outpar1 );
    traceModelOperationArgument( "AccountModel *"
                               , "acct"
                               , toCharArray_String(r(tmp_))
                               );
    destroy(tmp_);
    tmp_ = ts_to_trace_sectype( (SECTypeDesc*)&__type_desc__int, &params->res );
    traceModelOperationResult( "int"
                             , toCharArray_String(r(tmp_))
                             );
    destroy(tmp_);
    traceModelOperationChannel(chid);
    ts_trace_model_operation_timestamp(timestamp);
    traceModelOperationEnd();
    destroy(params);
}

SpecificationDesc desc_withdraw_spec =
{
    "withdraw_spec",
    "",
    "int withdraw_spec( AccountModel *acct, int sum )",
    (PreFuncType)__pre_withdraw_spec,
    (CallPureOracleFuncType)call_pure_oracle_withdraw_spec,
    (TraceModelOperationFuncType)trace_model_operation_withdraw_spec,
    0,
    &type_PAR_RES_TYPE_withdraw_spec
};

SpecificationID withdraw_spec = &desc_withdraw_spec;


static SubTypeDesc __type_desc__AccountModel;


static PointerTypeDesc __type_desc__ptr_to__AccountModel =
{ pointerType
, ((void*)0)
, ((void*)0)
, 1
, (SECTypeDesc*)&__type_desc__AccountModel
};

static StructTypeDesc __type_desc__Account;


static SubTypeDesc __type_desc__AccountModel = 
{ subType
, ((void*)0)
, ((void*)0)
, "AccountModel"
, (SECTypeDesc*)&__type_desc__Account
, (InvariantCheckerPtr)invariant_type_AccountModel
};



static FieldDesc __fields_desc__Account[] = 
{
    { "balance", ((char*)(&((Account*)0)->balance) - (char*)0), (SECTypeDesc*)&__type_desc__int }
};

static StructTypeDesc __type_desc__Account = 
{ structType
, ((void*)0)
, ((void*)0)
, "Account"
, sizeof( Account )
, 1
, __fields_desc__Account
};

static SimpleTypeDesc __type_desc__int =
{ simpleType
, ((void*)0)
, ((void*)0)
, "int"
, sizeof (int)
, "  d"
};








static FieldDesc __fields_desc__struct_PAR_RES_TYPE_deposit_spec[] = 
{
    { "inpar1", ((char*)(&((struct PAR_RES_TYPE_deposit_spec*)0)->inpar1) - (char*)0), (SECTypeDesc*)&__type_desc__ptr_to__AccountModel },
    { "inpar2", ((char*)(&((struct PAR_RES_TYPE_deposit_spec*)0)->inpar2) - (char*)0), (SECTypeDesc*)&__type_desc__int },
    { "outpar1", ((char*)(&((struct PAR_RES_TYPE_deposit_spec*)0)->outpar1) - (char*)0), (SECTypeDesc*)&__type_desc__ptr_to__AccountModel },
    { "outpar2", ((char*)(&((struct PAR_RES_TYPE_deposit_spec*)0)->outpar2) - (char*)0), (SECTypeDesc*)&__type_desc__int }
};

static StructTypeDesc __type_desc__struct_PAR_RES_TYPE_deposit_spec = 
{ structType
, ((void*)0)
, ((void*)0)
, "struct PAR_RES_TYPE_deposit_spec"
, sizeof( struct PAR_RES_TYPE_deposit_spec )
, 4
, __fields_desc__struct_PAR_RES_TYPE_deposit_spec
};










static FieldDesc __fields_desc__struct_PAR_RES_TYPE_withdraw_spec[] = 
{
    { "inpar1", ((char*)(&((struct PAR_RES_TYPE_withdraw_spec*)0)->inpar1) - (char*)0), (SECTypeDesc*)&__type_desc__ptr_to__AccountModel },
    { "inpar2", ((char*)(&((struct PAR_RES_TYPE_withdraw_spec*)0)->inpar2) - (char*)0), (SECTypeDesc*)&__type_desc__int },
    { "outpar1", ((char*)(&((struct PAR_RES_TYPE_withdraw_spec*)0)->outpar1) - (char*)0), (SECTypeDesc*)&__type_desc__ptr_to__AccountModel },
    { "outpar2", ((char*)(&((struct PAR_RES_TYPE_withdraw_spec*)0)->outpar2) - (char*)0), (SECTypeDesc*)&__type_desc__int },
    { "res", ((char*)(&((struct PAR_RES_TYPE_withdraw_spec*)0)->res) - (char*)0), (SECTypeDesc*)&__type_desc__int }
};

static StructTypeDesc __type_desc__struct_PAR_RES_TYPE_withdraw_spec = 
{ structType
, ((void*)0)
, ((void*)0)
, "struct PAR_RES_TYPE_withdraw_spec"
, sizeof( struct PAR_RES_TYPE_withdraw_spec )
, 5
, __fields_desc__struct_PAR_RES_TYPE_withdraw_spec
};






